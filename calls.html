<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#4F46E5">
    <link rel="icon" href="../icons/moodchat-192.png">
    <link rel="icon" href="../icons/moodchat-512.png">
    <meta name="theme-color" content="#000000">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Calls | Chat App</title>
    
    <!-- Removed Firebase SDK imports -->
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PeerJS for WebRTC -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- Simple Markdown for notes -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- M-Pesa payment integration -->
    <script src="https://js.paystack.co/v1/inline.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary-color: #0084ff;
            --secondary-color: #f0f2f5;
            --danger-color: #ff3b30;
            --success-color: #34c759;
            --warning-color: #ff9500;
            --text-primary: #050505;
            --text-secondary: #65676b;
            --bg-color: #ffffff;
            --border-color: #dddfe2;
            --call-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.2);
            --video-bg: #1a1a1a;
            --offline-overlay: rgba(255, 255, 255, 0.95);
            --premium-color: #FFD700;
            --premium-gradient: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            --happy-color: #FFD700;
            --neutral-color: #A0A0A0;
            --sad-color: #6495ED;
            --angry-color: #FF4500;
            --tired-color: #9370DB;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
        }
        
        /* Improved Offline Indicator */
        .offline-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--warning-color);
            color: white;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .offline-banner.active {
            display: flex;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 380px;
            background-color: var(--bg-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            position: relative;
        }
        
        .sidebar-header {
            padding: 20px;
            background: var(--call-gradient);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .sidebar-header h2 {
            font-size: 24px;
            font-weight: 600;
        }
        
        .new-call-btn {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        
        .new-call-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .new-call-btn:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .call-categories {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color);
            flex-shrink: 0;
        }
        
        .category-btn {
            flex: 1;
            padding: 15px;
            text-align: center;
            font-weight: 500;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        
        .category-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .category-btn:hover {
            background-color: var(--secondary-color);
        }
        
        .call-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .call-list-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .section-title {
            padding: 15px 20px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .offline-badge {
            background-color: var(--secondary-color);
            color: var(--text-secondary);
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 500;
        }
        
        /* Sync Indicator */
        .sync-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 500;
            margin-left: 8px;
            background-color: var(--secondary-color);
            color: var(--text-secondary);
        }
        
        .sync-indicator.syncing {
            background-color: rgba(0, 132, 255, 0.1);
            color: var(--primary-color);
            animation: pulse 2s infinite;
        }
        
        .sync-indicator i {
            font-size: 10px;
        }
        
        .quick-actions {
            padding: 0 20px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-shrink: 0;
        }
        
        .quick-action-btn {
            flex: 1;
            padding: 20px 15px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            transition: all 0.2s;
            position: relative;
        }
        
        .quick-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: var(--secondary-color);
        }
        
        .quick-action-btn:hover:not(:disabled) {
            background-color: #e4e6e9;
            transform: translateY(-2px);
        }
        
        .quick-action-icon {
            font-size: 24px;
            color: var(--primary-color);
        }
        
        .quick-action-text {
            font-size: 14px;
            font-weight: 500;
        }
        
        .call-settings {
            padding: 0 20px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .settings-toggle:hover {
            background-color: #e4e6e9;
        }
        
        .settings-toggle-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }
        
        .settings-toggle-icon {
            font-size: 18px;
            color: var(--primary-color);
        }
        
        .settings-panel {
            background-color: var(--secondary-color);
            border-radius: 12px;
            padding: 20px;
            margin-top: 10px;
            display: none;
        }
        
        .settings-panel.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        .settings-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-item:last-child {
            border-bottom: none;
        }
        
        .settings-item-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        
        .settings-item-icon {
            font-size: 16px;
            color: var(--primary-color);
            width: 24px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .recent-calls {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .calls-section {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
        }
        
        .calls-section.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        
        .calls-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
            min-height: 200px;
        }
        
        /* Improved Offline State */
        .offline-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            color: var(--text-secondary);
            text-align: center;
            background-color: var(--bg-color);
        }
        
        .offline-state i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .offline-state p {
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .offline-state .subtext {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.7;
        }
        
        .call-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            background-color: var(--bg-color);
            border-radius: 12px;
            margin: 0 20px 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .call-item:hover {
            background-color: var(--secondary-color);
            border-color: var(--primary-color);
        }
        
        .call-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .call-status-icon {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--bg-color);
            font-size: 10px;
        }
        
        .call-status-icon.incoming {
            background-color: var(--success-color);
            color: white;
        }
        
        .call-status-icon.outgoing {
            background-color: var(--primary-color);
            color: white;
        }
        
        .call-status-icon.missed {
            background-color: var(--danger-color);
            color: white;
        }
        
        .call-info {
            flex: 1;
        }
        
        .call-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .call-details {
            color: var(--text-secondary);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .call-time {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .call-action-btn {
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .call-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .call-action-btn:hover:not(:disabled) {
            background-color: var(--secondary-color);
        }
        
        /* Call Container */
        .call-container {
            flex: 1;
            background-color: var(--video-bg);
            position: relative;
            display: none;
            overflow: hidden;
        }
        
        .call-container.active {
            display: flex;
            flex-direction: column;
        }
        
        .call-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
        }
        
        .call-info-bar {
            display: flex;
            align-items: center;
            color: white;
        }
        
        .call-type-icon {
            background: rgba(255, 255, 255, 0.1);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 18px;
            backdrop-filter: blur(10px);
        }
        
        .call-info-text h4 {
            font-size: 17px;
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        .call-info-text p {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .call-duration {
            color: white;
            font-weight: 500;
            font-size: 18px;
        }
        
        /* Video Grid */
        .video-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            padding: 20px;
            overflow: auto;
        }
        
        .video-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background-color: #2a2a2a;
            aspect-ratio: 16/9;
        }
        
        .video-container.large {
            grid-column: span 2;
            grid-row: span 2;
        }
        
        .video-container.pinned {
            border: 3px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(0, 132, 255, 0.5);
        }
        
        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .video-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .video-name {
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .video-status {
            font-size: 12px;
            opacity: 0.8;
        }
        
        .video-actions {
            display: flex;
            gap: 5px;
        }
        
        .video-action-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        
        .video-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .video-action-btn.active {
            background-color: var(--primary-color);
        }
        
        .video-action-btn.danger {
            background-color: var(--danger-color);
        }
        
        /* Call Controls */
        .call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .control-btn.active {
            background-color: var(--primary-color);
        }
        
        .control-btn.danger {
            background-color: var(--danger-color);
        }
        
        .control-btn.danger:hover {
            background-color: #ff1a1a;
        }
        
        /* Premium Badge */
        .premium-badge {
            background: var(--premium-gradient);
            color: #000;
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        /* Call Side Panel */
        .call-side-panel {
            width: 300px;
            background-color: var(--bg-color);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        .call-side-panel.collapsed {
            transform: translateX(100%);
        }
        
        .panel-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-header h3 {
            font-size: 18px;
            font-weight: 600;
        }
        
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }
        
        .panel-tab {
            flex: 1;
            min-width: 80px;
            padding: 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        
        .panel-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .panel-section {
            display: none;
        }
        
        .panel-section.active {
            display: block;
        }
        
        /* Participants List */
        .participants-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .participant-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            background-color: var(--bg-color);
            transition: all 0.2s;
        }
        
        .participant-item:hover {
            background-color: var(--secondary-color);
        }
        
        .participant-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            margin-right: 12px;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .participant-info {
            flex: 1;
        }
        
        .participant-name {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 3px;
        }
        
        .participant-status {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .participant-status.active {
            color: var(--success-color);
        }
        
        .participant-status.offline {
            color: var(--text-secondary);
        }
        
        .participant-actions {
            display: flex;
            gap: 5px;
        }
        
        /* Chat Panel */
        .chat-messages {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .chat-message {
            padding: 10px 15px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .chat-message.sent {
            background-color: var(--primary-color);
            color: white;
            align-self: flex-end;
        }
        
        .chat-message.received {
            background-color: var(--secondary-color);
            align-self: flex-start;
        }
        
        .message-sender {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 3px;
        }
        
        .message-content {
            font-size: 14px;
        }
        
        .chat-input {
            display: flex;
            gap: 10px;
        }
        
        .chat-input-field {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 14px;
        }
        
        /* Notes Panel */
        .notes-editor {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .notes-toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .notes-btn {
            padding: 8px 12px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }
        
        .notes-btn:hover {
            background-color: #e4e6e9;
        }
        
        .notes-input {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        .notes-preview {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--secondary-color);
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* Whiteboard Panel */
        .whiteboard-container {
            width: 100%;
            height: 400px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background-color: white;
            margin-bottom: 15px;
        }
        
        .whiteboard-tools {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        /* Poll Panel */
        .poll-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .poll-question {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--secondary-color);
        }
        
        .poll-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .poll-option {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .poll-option:hover {
            background-color: var(--secondary-color);
        }
        
        .poll-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 132, 255, 0.1);
        }
        
        .poll-option-text {
            flex: 1;
        }
        
        .poll-votes {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* Reactions */
        .reactions-container {
            position: absolute;
            bottom: 120px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 50;
        }
        
        .reaction-btn {
            background: rgba(255, 255, 255, 0.9);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .reaction-btn:hover {
            transform: scale(1.1);
        }
        
        /* Floating Reactions Animation */
        .floating-reaction {
            position: absolute;
            font-size: 40px;
            z-index: 1000;
            pointer-events: none;
            animation: floatUp 3s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(1);
                opacity: 0;
            }
        }
        
        /* Incoming Call Modal */
        .incoming-call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .incoming-call-modal.active {
            display: flex;
        }
        
        .incoming-call-container {
            width: 90%;
            max-width: 400px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            text-align: center;
            padding: 30px;
            box-shadow: var(--shadow-lg);
        }
        
        .incoming-call-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: white;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .incoming-call-name {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .incoming-call-type {
            color: var(--text-secondary);
            margin-bottom: 30px;
        }
        
        .incoming-call-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        /* New Call Modal */
        .new-call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .new-call-modal.active {
            display: flex;
        }
        
        .new-call-container {
            width: 90%;
            max-width: 500px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            box-shadow: var(--shadow-lg);
        }
        
        .new-call-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--call-gradient);
            color: white;
        }
        
        .new-call-header h3 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .new-call-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }
        
        .new-call-tab {
            flex: 1;
            min-width: 100px;
            padding: 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        
        .new-call-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .new-call-content {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }
        
        .new-call-tab-content {
            display: none;
        }
        
        .new-call-tab-content.active {
            display: block;
        }
        
        .contact-search {
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
        }
        
        .contacts-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .contact-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .contact-item:hover {
            background-color: var(--secondary-color);
        }
        
        .contact-item.selected {
            background-color: rgba(0, 132, 255, 0.1);
            border: 1px solid var(--primary-color);
        }
        
        .contact-checkbox {
            margin-right: 12px;
        }
        
        .group-call-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .option-item {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .option-item:hover {
            background-color: var(--secondary-color);
        }
        
        .option-item.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 132, 255, 0.1);
        }
        
        .option-title {
            font-weight: 600;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .option-desc {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        /* Call Link Tab */
        .link-tab-content {
            text-align: center;
            padding: 30px 0;
        }
        
        .link-icon {
            font-size: 48px;
            margin-bottom: 20px;
            color: var(--primary-color);
        }
        
        /* Payment Modal */
        .payment-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            align-items: center;
            justify-content: center;
        }
        
        .payment-modal.active {
            display: flex;
        }
        
        .payment-container {
            width: 90%;
            max-width: 400px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            text-align: center;
            padding: 30px;
            box-shadow: var(--shadow-lg);
        }
        
        .payment-header {
            margin-bottom: 20px;
        }
        
        .payment-header h3 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .payment-amount {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary-color);
            margin: 20px 0;
        }
        
        .payment-option {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .payment-option:hover {
            background-color: var(--secondary-color);
        }
        
        .payment-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 132, 255, 0.1);
        }
        
        .payment-icon {
            font-size: 24px;
            margin-right: 15px;
            color: var(--primary-color);
        }
        
        .payment-details {
            flex: 1;
            text-align: left;
        }
        
        .payment-details h4 {
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .payment-details p {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .payment-form {
            margin-top: 20px;
            text-align: left;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
        }
        
        .payment-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .payment-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .payment-btn.primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .payment-btn.primary:hover {
            background-color: #0066cc;
        }
        
        .payment-btn.secondary {
            background-color: var(--secondary-color);
            color: var(--text-primary);
        }
        
        .payment-btn.secondary:hover {
            background-color: #e4e6e9;
        }
        
        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--success-color);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }
        
        .notification.active {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.error {
            background-color: var(--danger-color);
        }
        
        .notification.warning {
            background-color: var(--warning-color);
        }
        
        /* Picture in Picture */
        .pip-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            background-color: var(--video-bg);
            box-shadow: var(--shadow-lg);
            z-index: 999;
            cursor: move;
            resize: both;
            overflow: hidden;
            display: none;
        }
        
        .pip-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .pip-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            display: flex;
            justify-content: center;
            gap: 5px;
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 350px;
            }
            
            .call-side-panel {
                width: 250px;
            }
        }
        
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 70vh;
                min-height: 500px;
            }
            
            .call-container {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 100;
            }
            
            .call-side-panel {
                position: fixed;
                top: 0;
                right: 0;
                width: 100%;
                height: 100%;
                z-index: 200;
            }
            
            .call-list {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-height: 300px;
            }
            
            .recent-calls {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }
            
            .calls-section {
                flex: 1;
                display: none;
                flex-direction: column;
                overflow: hidden;
            }
            
            .calls-section.active {
                display: flex;
                animation: fadeIn 0.3s ease;
            }
            
            .calls-list {
                flex: 1;
                overflow-y: auto;
                padding: 10px 0;
                min-height: 250px;
            }
            
            .call-item {
                padding: 12px 20px;
                margin: 0 15px 8px 15px;
            }
            
            .call-avatar {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            .call-name {
                font-size: 15px;
            }
            
            .call-details {
                font-size: 13px;
            }
            
            .quick-actions {
                padding: 0 15px;
                gap: 10px;
                flex-wrap: wrap;
            }
            
            .quick-action-btn {
                padding: 15px 10px;
                min-width: 100px;
            }
            
            .quick-action-icon {
                font-size: 20px;
            }
            
            .quick-action-text {
                font-size: 13px;
            }
            
            .call-settings {
                padding: 0 15px;
            }
            
            .section-title {
                padding: 15px;
            }
        }
        
        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulsing {
            animation: pulse 2s infinite;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease;
        }
        
        /* Offline UI - Clean like Friends Page */
        .offline-ui .quick-action-btn,
        .offline-ui .new-call-btn,
        .offline-ui .control-btn:not(#endCallBtn),
        .offline-ui .call-action-btn,
        .offline-ui .notes-btn:not(#resetSettingsBtn),
        .offline-ui .panel-tab:not(.active) {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .offline-ui .contact-checkbox {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Improved Offline Call Container */
        .offline-call-placeholder {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 40px;
            background-color: var(--video-bg);
        }
        
        .offline-call-placeholder i {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.7;
        }
        
        .offline-call-placeholder h3 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .offline-call-placeholder p {
            font-size: 16px;
            opacity: 0.8;
            margin-bottom: 30px;
            max-width: 400px;
            line-height: 1.5;
        }
        
        /* Offline Contacts */
        .offline-contacts-message {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        .offline-contacts-message i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .offline-contacts-message p {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .offline-contacts-message .subtext {
            font-size: 14px;
            opacity: 0.7;
        }
        
        /* Premium Features */
        .premium-feature {
            position: relative;
        }
        
        .premium-badge-small {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--premium-gradient);
            color: #000;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
            z-index: 1;
        }
        
        /* Loading Spinner */
        .loading-placeholder {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        .loading-spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid rgba(0, 132, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* ==================== NEW UNIQUE FEATURES STYLES ==================== */
        
        /* Emotional Context Styles */
        .mood-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            margin-left: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .mood-happy {
            background-color: rgba(255, 215, 0, 0.2);
            color: var(--happy-color);
        }
        
        .mood-neutral {
            background-color: rgba(160, 160, 160, 0.2);
            color: var(--neutral-color);
        }
        
        .mood-sad {
            background-color: rgba(100, 149, 237, 0.2);
            color: var(--sad-color);
        }
        
        .mood-angry {
            background-color: rgba(255, 69, 0, 0.2);
            color: var(--angry-color);
        }
        
        .mood-tired {
            background-color: rgba(147, 112, 219, 0.2);
            color: var(--tired-color);
        }
        
        /* Call Intention Styles */
        .intention-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: 500;
            margin-top: 3px;
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .intention-quick {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }
        
        .intention-important {
            background-color: rgba(255, 152, 0, 0.3);
            color: #FF9800;
        }
        
        .intention-emergency {
            background-color: rgba(244, 67, 54, 0.3);
            color: #F44336;
        }
        
        .intention-checkin {
            background-color: rgba(33, 150, 243, 0.3);
            color: #2196F3;
        }
        
        .intention-work {
            background-color: rgba(156, 39, 176, 0.3);
            color: #9C27B0;
        }
        
        /* Private Call Notes Styles */
        .private-notes-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background-color: rgba(26, 26, 26, 0.95);
            border-radius: 16px;
            padding: 25px;
            z-index: 200;
            display: none;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .private-notes-container.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        .private-notes-header {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .private-notes-header h3 {
            color: white;
            font-size: 20px;
            margin-bottom: 8px;
        }
        
        .private-notes-header p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
        }
        
        .private-notes-textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .private-notes-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: rgba(255, 255, 255, 0.08);
        }
        
        .private-notes-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        /* Call Summary Snapshot */
        .call-summary-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1002;
            align-items: center;
            justify-content: center;
        }
        
        .call-summary-modal.active {
            display: flex;
        }
        
        .call-summary-container {
            width: 90%;
            max-width: 500px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
        }
        
        .call-summary-header {
            padding: 25px;
            background: var(--call-gradient);
            color: white;
            text-align: center;
        }
        
        .call-summary-header h3 {
            font-size: 22px;
            margin-bottom: 5px;
        }
        
        .call-summary-content {
            padding: 25px;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .summary-item:last-child {
            border-bottom: none;
        }
        
        .summary-label {
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .summary-value {
            font-weight: 500;
        }
        
        /* Relationship Memory */
        .relationship-memory {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 3px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .relationship-memory i {
            font-size: 10px;
        }
        
        .frequent-contact {
            color: var(--success-color);
        }
        
        .recent-contact {
            color: var(--primary-color);
        }
        
        .occasional-contact {
            color: var(--warning-color);
        }
        
        /* Focus Mode */
        .focus-mode-btn {
            position: absolute;
            top: 20px;
            right: 90px;
            z-index: 101;
        }
        
        .focus-mode .video-overlay,
        .focus-mode .reactions-container,
        .focus-mode .call-side-panel:not(.collapsed) {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .focus-mode .call-header {
            background: rgba(0, 0, 0, 0.9);
        }
        
        .focus-mode .call-controls {
            opacity: 0.3;
            transition: opacity 0.3s;
        }
        
        .focus-mode .call-controls:hover {
            opacity: 1;
        }
        
        /* Mood Selection Modal */
        .mood-selection-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1003;
            align-items: center;
            justify-content: center;
        }
        
        .mood-selection-modal.active {
            display: flex;
        }
        
        .mood-selection-container {
            width: 90%;
            max-width: 400px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            padding: 30px;
            text-align: center;
            box-shadow: var(--shadow-lg);
        }
        
        .mood-selection-title {
            font-size: 20px;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .mood-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .mood-option {
            padding: 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .mood-option:hover {
            transform: translateY(-2px);
            border-color: var(--primary-color);
        }
        
        .mood-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 132, 255, 0.1);
        }
        
        .mood-emoji {
            font-size: 32px;
        }
        
        .mood-name {
            font-size: 14px;
            font-weight: 500;
        }
        
        /* Intention Selection Modal */
        .intention-selection-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1004;
            align-items: center;
            justify-content: center;
        }
        
        .intention-selection-modal.active {
            display: flex;
        }
        
        .intention-selection-container {
            width: 90%;
            max-width: 450px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            padding: 30px;
            text-align: center;
            box-shadow: var(--shadow-lg);
        }
        
        .intention-selection-title {
            font-size: 20px;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .intention-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 25px;
        }
        
        .intention-option {
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .intention-option:hover {
            transform: translateY(-2px);
            border-color: var(--primary-color);
        }
        
        .intention-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 132, 255, 0.1);
        }
        
        .intention-icon {
            font-size: 20px;
            color: var(--primary-color);
        }
        
        .intention-text {
            flex: 1;
        }
        
        .intention-title {
            font-weight: 500;
            margin-bottom: 3px;
        }
        
        .intention-desc {
            font-size: 12px;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <!-- Simple Offline Banner -->
    <div class="offline-banner" id="offlineBanner">
        <i class="fas fa-wifi-slash"></i>
        <span>You are currently offline. Call features will be available when connection is restored.</span>
    </div>
    
    <div class="app-container">
        <!-- Sidebar with call history -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Calls</h2>
                <button class="new-call-btn" id="newCallBtn" title="Start new call">
                    <i class="fas fa-phone-alt"></i>
                </button>
            </div>
            
            <div class="call-categories">
                <button class="category-btn active" id="allTab">All</button>
                <button class="category-btn" id="missedTab">Missed</button>
                <button class="category-btn" id="groupsTab">Groups</button>
            </div>
            
            <div class="call-list">
                <div class="quick-actions">
                    <button class="quick-action-btn" id="voiceCallBtn" title="Start voice call">
                        <div class="quick-action-icon">
                            <i class="fas fa-phone"></i>
                        </div>
                        <div class="quick-action-text">Voice Call</div>
                    </button>
                    <button class="quick-action-btn" id="videoCallBtn" title="Start video call">
                        <div class="quick-action-icon">
                            <i class="fas fa-video"></i>
                        </div>
                        <div class="quick-action-text">Video Call</div>
                    </button>
                    <button class="quick-action-btn" id="groupCallBtn" title="Start group call">
                        <div class="quick-action-icon">
                            <i class="fas fa-users"></i>
                        </div>
                        <div class="quick-action-text">Group Call</div>
                        <div class="premium-badge-small">Free</div>
                    </button>
                </div>
                
                <!-- Call Settings Panel -->
                <div class="call-settings">
                    <div class="settings-toggle" id="settingsToggle">
                        <div class="settings-toggle-title">
                            <i class="fas fa-cog settings-toggle-icon"></i>
                            <span>Call Settings</span>
                        </div>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    
                    <div class="settings-panel" id="settingsPanel">
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-smile settings-item-icon"></i>
                                <span>Live Reactions</span>
                                <span class="premium-badge-small">Free</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="reactionsToggle" data-setting="liveReactions">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-comment settings-item-icon"></i>
                                <span>In-call Chat</span>
                                <span class="premium-badge-small">Free</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="chatToggle" data-setting="inCallChat">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-paint-brush settings-item-icon"></i>
                                <span>Shared Whiteboard</span>
                                <span class="premium-badge-small">Free</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="whiteboardToggle" data-setting="sharedWhiteboard">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-poll settings-item-icon"></i>
                                <span>Polls</span>
                                <span class="premium-badge-small">Free</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="pollsToggle" data-setting="polls">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-sticky-note settings-item-icon"></i>
                                <span>Shared Notes</span>
                                <span class="premium-badge-small">Free</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="notesToggle" data-setting="sharedNotes">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <!-- NEW: Emotional Context Setting -->
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-heart settings-item-icon"></i>
                                <span>Emotional Context</span>
                                <span class="premium-badge-small">Unique</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="emotionalContextToggle" data-setting="emotionalContext">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <!-- NEW: Call Intention Setting -->
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-bullseye settings-item-icon"></i>
                                <span>Call Intention</span>
                                <span class="premium-badge-small">Unique</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="callIntentionToggle" data-setting="callIntention">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <!-- NEW: Focus Mode Setting -->
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-eye settings-item-icon"></i>
                                <span>Focus Mode</span>
                                <span class="premium-badge-small">Unique</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="focusModeToggle" data-setting="focusMode">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <button class="notes-btn" id="resetSettingsBtn" style="width: 100%; margin-top: 10px;">
                                <i class="fas fa-undo"></i> Reset Call Settings
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="recent-calls">
                    <div class="section-title">
                        <span>Recent Calls</span>
                        <span id="syncIndicator" class="sync-indicator">
                            <i class="fas fa-check-circle"></i> Ready
                        </span>
                    </div>
                    <div class="call-list-content">
                        <!-- All Calls Section -->
                        <div class="calls-section active" id="allCallsSection">
                            <div class="calls-list" id="allCallsList">
                                <!-- Calls will be loaded from cache instantly -->
                            </div>
                        </div>
                        
                        <!-- Missed Calls Section -->
                        <div class="calls-section" id="missedCallsSection">
                            <div class="calls-list" id="missedCallsList">
                                <!-- Missed calls will be loaded here -->
                            </div>
                        </div>
                        
                        <!-- Group Calls Section -->
                        <div class="calls-section" id="groupCallsSection">
                            <div class="calls-list" id="groupCallsList">
                                <!-- Group calls will be loaded here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Call Container -->
        <div class="call-container" id="callContainer">
            <button class="control-btn focus-mode-btn" id="focusModeBtn" title="Toggle Focus Mode">
                <i class="fas fa-eye"></i>
            </button>
            
            <div class="call-header">
                <div class="call-info-bar">
                    <div class="call-type-icon" id="callTypeIcon">
                        <i class="fas fa-video"></i>
                    </div>
                    <div class="call-info-text">
                        <h4 id="callParticipants">Ready to call</h4>
                        <p id="callStatus">Start a new call or wait for incoming calls</p>
                        <!-- Emotional Context Display -->
                        <div id="emotionalContextDisplay" style="display: none; margin-top: 5px;">
                            <span class="mood-indicator mood-neutral" id="callMoodDisplay">
                                <i class="fas fa-smile"></i> <span id="moodText">Neutral</span>
                            </span>
                            <span class="intention-indicator intention-checkin" id="callIntentionDisplay" style="display: none;">
                                <i class="fas fa-bullseye"></i> <span id="intentionText">Just checking in</span>
                            </span>
                        </div>
                    </div>
                </div>
                <div class="call-duration" id="callDuration">00:00</div>
            </div>
            
            <div class="video-grid" id="videoGrid">
                <!-- Video streams will be added here -->
                <div class="offline-call-placeholder" id="offlineCallPlaceholder" style="display: none;">
                    <i class="fas fa-wifi-slash"></i>
                    <h3>Connection Required</h3>
                    <p>Call features require internet connection.</p>
                </div>
            </div>
            
            <div class="reactions-container" id="reactionsContainer">
                <div class="reaction-btn" data-reaction=""></div>
                <div class="reaction-btn" data-reaction=""></div>
                <div class="reaction-btn" data-reaction=""></div>
                <div class="reaction-btn" data-reaction=""></div>
                <div class="reaction-btn" data-reaction=""></div>
            </div>
            
            <div class="call-controls">
                <button class="control-btn" id="muteBtn" title="Mute">
                    <i class="fas fa-microphone"></i>
                </button>
                <button class="control-btn" id="videoBtn" title="Video">
                    <i class="fas fa-video"></i>
                </button>
                <button class="control-btn" id="speakerBtn" title="Speaker">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button class="control-btn" id="screenShareBtn" title="Share Screen">
                    <i class="fas fa-desktop"></i>
                </button>
                <button class="control-btn" id="effectsBtn" title="Effects">
                    <i class="fas fa-magic"></i>
                </button>
                <!-- NEW: Mood Button -->
                <button class="control-btn" id="moodBtn" title="Set Mood">
                    <i class="fas fa-smile"></i>
                </button>
                <!-- NEW: Intention Button -->
                <button class="control-btn" id="intentionBtn" title="Set Intention">
                    <i class="fas fa-bullseye"></i>
                </button>
                <button class="control-btn" id="moreBtn" title="More Options">
                    <i class="fas fa-ellipsis-h"></i>
                </button>
                <button class="control-btn danger" id="endCallBtn" title="End Call">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
        
        <!-- Call Side Panel -->
        <div class="call-side-panel collapsed" id="callSidePanel">
            <div class="panel-header">
                <h3 id="panelTitle">Call Controls</h3>
                <button class="call-action-btn" id="closePanelBtn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="panel-tabs" id="panelTabs">
                <button class="panel-tab active" data-panel="participants">Participants</button>
                <button class="panel-tab" data-panel="chat">Chat</button>
                <button class="panel-tab" data-panel="whiteboard">Whiteboard</button>
                <button class="panel-tab" data-panel="notes">Notes</button>
                <button class="panel-tab" data-panel="polls">Polls</button>
                <!-- NEW: Relationship Memory Tab -->
                <button class="panel-tab" data-panel="relationship">Memory</button>
            </div>
            
            <div class="panel-content" id="panelContent">
                <!-- Participants Panel -->
                <div class="panel-section active" id="participantsPanel">
                    <div class="participants-list" id="participantsList">
                        <!-- Participants will be listed here -->
                    </div>
                    <div style="margin-top: 20px;">
                        <button class="notes-btn" id="addParticipantsBtn" style="width: 100%;">
                            <i class="fas fa-user-plus"></i> Add Participants
                        </button>
                    </div>
                </div>
                
                <!-- Chat Panel -->
                <div class="panel-section" id="chatPanel">
                    <div class="chat-messages" id="chatMessages">
                        <!-- Chat messages will be shown here -->
                    </div>
                    <div class="chat-input">
                        <input type="text" class="chat-input-field" id="chatInput" placeholder="Type a message...">
                        <button class="video-action-btn" id="sendChatBtn">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Whiteboard Panel -->
                <div class="panel-section" id="whiteboardPanel">
                    <div class="whiteboard-container">
                        <canvas id="whiteboardCanvas"></canvas>
                    </div>
                    <div class="whiteboard-tools">
                        <button class="notes-btn" data-tool="pencil">
                            <i class="fas fa-pencil-alt"></i> Pencil
                        </button>
                        <button class="notes-btn" data-tool="line">
                            <i class="fas fa-minus"></i> Line
                        </button>
                        <button class="notes-btn" data-tool="rectangle">
                            <i class="fas fa-square"></i> Rectangle
                        </button>
                        <button class="notes-btn" data-tool="circle">
                            <i class="fas fa-circle"></i> Circle
                        </button>
                        <button class="notes-btn" data-tool="text">
                            <i class="fas fa-font"></i> Text
                        </button>
                        <button class="notes-btn" id="clearWhiteboardBtn">
                            <i class="fas fa-trash"></i> Clear
                        </button>
                    </div>
                </div>
                
                <!-- Notes Panel -->
                <div class="panel-section" id="notesPanel">
                    <div class="notes-editor">
                        <div class="notes-toolbar">
                            <button class="notes-btn" id="saveNoteBtn">
                                <i class="fas fa-save"></i> Save
                            </button>
                            <button class="notes-btn" id="shareNoteBtn">
                                <i class="fas fa-share"></i> Share
                            </button>
                            <button class="notes-btn" id="loadNotesBtn">
                                <i class="fas fa-history"></i> Load Previous
                            </button>
                        </div>
                        <textarea class="notes-input" id="notesInput" placeholder="Take notes during the call..."></textarea>
                        <div class="notes-preview" id="notesPreview">
                            <!-- Notes preview will appear here -->
                        </div>
                    </div>
                </div>
                
                <!-- Polls Panel -->
                <div class="panel-section" id="pollsPanel">
                    <div class="poll-container">
                        <div id="activePoll">
                            <!-- Active poll will be shown here -->
                        </div>
                        <div style="margin-top: 20px;">
                            <button class="notes-btn" id="createPollBtn" style="width: 100%;">
                                <i class="fas fa-plus"></i> Create New Poll
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- NEW: Relationship Memory Panel -->
                <div class="panel-section" id="relationshipPanel">
                    <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                        <i class="fas fa-brain" style="font-size: 48px; margin-bottom: 15px; opacity: 0.7;"></i>
                        <h4 style="margin-bottom: 10px;">Relationship Memory</h4>
                        <p style="margin-bottom: 20px; font-size: 14px;">See insights about your calling patterns</p>
                    </div>
                    <div id="relationshipInsights">
                        <!-- Relationship insights will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Call Modal -->
    <div class="new-call-modal" id="newCallModal">
        <div class="new-call-container">
            <div class="new-call-header">
                <h3>Start New Call</h3>
                <button class="new-call-btn" id="closeNewCallModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="new-call-tabs">
                <button class="new-call-tab active" data-tab="contacts">Contacts</button>
                <button class="new-call-tab" data-tab="group">Group Call</button>
                <button class="new-call-tab" data-tab="link">Call Link</button>
            </div>
            
            <div class="new-call-content">
                <!-- Contacts Tab -->
                <div class="new-call-tab-content active" id="contactsTab">
                    <div class="contact-search">
                        <input type="text" class="search-input" id="contactSearch" placeholder="Search contacts...">
                    </div>
                    <div class="contacts-list" id="contactsList">
                        <!-- Contacts will be loaded here -->
                    </div>
                </div>
                
                <!-- Group Call Tab -->
                <div class="new-call-tab-content" id="groupTab">
                    <div class="group-call-options">
                        <div class="option-item" data-type="instant">
                            <div class="option-title">
                                <i class="fas fa-bolt"></i> Instant Group Call
                            </div>
                            <div class="option-desc">Start a call and add participants as you go</div>
                        </div>
                        <div class="option-item" data-type="scheduled">
                            <div class="option-title">
                                <i class="fas fa-calendar"></i> Schedule Group Call
                            </div>
                            <div class="option-desc">Schedule a call for later and send invites</div>
                        </div>
                    </div>
                    <div style="margin-top: 20px;">
                        <h4 style="margin-bottom: 10px;">Select Participants</h4>
                        <div class="contacts-list" id="groupContactsList">
                            <!-- Group contacts will be loaded here -->
                        </div>
                    </div>
                </div>
                
                <!-- Call Link Tab -->
                <div class="new-call-tab-content" id="linkTab">
                    <div style="text-align: center; padding: 30px 0;">
                        <div style="font-size: 48px; margin-bottom: 20px; color: var(--primary-color);">
                            <i class="fas fa-link"></i>
                        </div>
                        <h3 style="margin-bottom: 10px;">Create Call Link</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">
                            Create a shareable link for anyone to join your call
                        </p>
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <button class="notes-btn" id="createVoiceLinkBtn">
                                <i class="fas fa-phone"></i> Voice Call Link
                            </button>
                            <button class="notes-btn" id="createVideoLinkBtn">
                                <i class="fas fa-video"></i> Video Call Link
                            </button>
                        </div>
                        <div id="callLinkContainer" style="display: none;">
                            <div style="margin-bottom: 15px;">
                                <input type="text" id="callLinkInput" readonly style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 8px;">
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="notes-btn" id="copyLinkBtn">
                                    <i class="fas fa-copy"></i> Copy Link
                                </button>
                                <button class="notes-btn" id="shareLinkBtn">
                                    <i class="fas fa-share"></i> Share
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="padding: 20px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between;">
                <button class="notes-btn" id="cancelNewCallBtn">Cancel</button>
                <button class="notes-btn" id="startCallBtn" style="background-color: var(--primary-color); color: white;">Start Call</button>
            </div>
        </div>
    </div>
    
    <!-- Incoming Call Modal -->
    <div class="incoming-call-modal" id="incomingCallModal">
        <div class="incoming-call-container">
            <div class="incoming-call-avatar" id="incomingCallAvatar">
                <i class="fas fa-user"></i>
            </div>
            <div class="incoming-call-name" id="incomingCallName">John Doe</div>
            <div class="incoming-call-type" id="incomingCallType">Incoming Video Call</div>
            <!-- Emotional Context for Incoming Call -->
            <div id="incomingCallEmotionalContext" style="margin-bottom: 20px; display: none;">
                <span class="mood-indicator mood-neutral" id="incomingCallMood">
                    <i class="fas fa-smile"></i> <span id="incomingMoodText">Neutral</span>
                </span>
                <span class="intention-indicator intention-checkin" id="incomingCallIntention" style="margin-left: 10px;">
                    <i class="fas fa-bullseye"></i> <span id="incomingIntentionText">Just checking in</span>
                </span>
            </div>
            <div class="incoming-call-actions">
                <button class="control-btn danger pulsing" id="declineCallBtn">
                    <i class="fas fa-phone-slash"></i>
                </button>
                <button class="control-btn active pulsing" id="acceptCallBtn">
                    <i class="fas fa-phone"></i>
                </button>
                <button class="control-btn" id="acceptVideoCallBtn">
                    <i class="fas fa-video"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Payment Modal -->
    <div class="payment-modal" id="paymentModal">
        <div class="payment-container">
            <div class="payment-header">
                <h3>Upgrade to Premium</h3>
                <p>To add more than 8 participants to your group call</p>
            </div>
            
            <div class="payment-amount" id="paymentAmount">KSh 500</div>
            
            <div class="payment-option selected" id="mpesaOption">
                <i class="fas fa-mobile-alt payment-icon"></i>
                <div class="payment-details">
                    <h4>M-Pesa</h4>
                    <p>Pay via M-Pesa mobile money</p>
                </div>
            </div>
            
            <div class="payment-form">
                <div class="form-group">
                    <label class="form-label">Phone Number</label>
                    <input type="tel" class="form-input" id="phoneNumber" placeholder="07XXXXXXXX" maxlength="10">
                </div>
                <div class="form-group">
                    <label class="form-label">Amount (KES)</label>
                    <input type="number" class="form-input" id="paymentAmountInput" value="500" min="500" max="5000">
                </div>
            </div>
            
            <div class="payment-buttons">
                <button class="payment-btn secondary" id="cancelPaymentBtn">Cancel</button>
                <button class="payment-btn primary" id="confirmPaymentBtn">Pay Now</button>
            </div>
        </div>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">Operation completed successfully</span>
    </div>
    
    <!-- Picture in Picture Container -->
    <div class="pip-container" id="pipContainer">
        <video class="pip-video" id="pipVideo" autoplay muted></video>
        <div class="pip-controls">
            <button class="video-action-btn" id="pipExpandBtn">
                <i class="fas fa-expand"></i>
            </button>
            <button class="video-action-btn danger" id="pipEndBtn">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>
    
    <!-- ==================== NEW UNIQUE FEATURES MODALS ==================== -->
    
    <!-- Private Call Notes Modal -->
    <div class="private-notes-container" id="privateNotesModal">
        <div class="private-notes-header">
            <h3>Private Call Notes</h3>
            <p>Add private notes about this call. Only you can see these.</p>
        </div>
        <textarea class="private-notes-textarea" id="privateNotesTextarea" 
                  placeholder="What did you discuss? Any follow-up actions? Personal thoughts..."></textarea>
        <div class="private-notes-buttons">
            <button class="notes-btn" id="skipNotesBtn">Skip</button>
            <button class="notes-btn" id="savePrivateNotesBtn" style="background-color: var(--primary-color); color: white;">Save Notes</button>
        </div>
    </div>
    
    <!-- Call Summary Modal -->
    <div class="call-summary-modal" id="callSummaryModal">
        <div class="call-summary-container">
            <div class="call-summary-header">
                <h3>Call Summary</h3>
                <p>Review your call details</p>
            </div>
            <div class="call-summary-content">
                <div class="summary-item">
                    <span class="summary-label">Duration:</span>
                    <span class="summary-value" id="summaryDuration">00:00</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Time:</span>
                    <span class="summary-value" id="summaryTime">Just now</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Type:</span>
                    <span class="summary-value" id="summaryType">Video Call</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Mood:</span>
                    <span class="summary-value" id="summaryMood">Neutral</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Intention:</span>
                    <span class="summary-value" id="summaryIntention">Just checking in</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Participants:</span>
                    <span class="summary-value" id="summaryParticipants">2</span>
                </div>
                <div style="margin-top: 25px; text-align: center;">
                    <button class="notes-btn" id="closeSummaryBtn" style="width: 100%; background-color: var(--primary-color); color: white;">
                        Done
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Mood Selection Modal -->
    <div class="mood-selection-modal" id="moodSelectionModal">
        <div class="mood-selection-container">
            <div class="mood-selection-title">How are you feeling?</div>
            <div class="mood-options">
                <div class="mood-option" data-mood="happy">
                    <div class="mood-emoji"></div>
                    <div class="mood-name">Happy</div>
                </div>
                <div class="mood-option" data-mood="neutral">
                    <div class="mood-emoji"></div>
                    <div class="mood-name">Neutral</div>
                </div>
                <div class="mood-option" data-mood="sad">
                    <div class="mood-emoji"></div>
                    <div class="mood-name">Sad</div>
                </div>
                <div class="mood-option" data-mood="angry">
                    <div class="mood-emoji"></div>
                    <div class="mood-name">Angry</div>
                </div>
                <div class="mood-option" data-mood="tired">
                    <div class="mood-emoji"></div>
                    <div class="mood-name">Tired</div>
                </div>
                <div class="mood-option" data-mood="excited">
                    <div class="mood-emoji"></div>
                    <div class="mood-name">Excited</div>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="notes-btn" id="cancelMoodBtn" style="flex: 1;">Cancel</button>
                <button class="notes-btn" id="confirmMoodBtn" style="flex: 1; background-color: var(--primary-color); color: white;">Set Mood</button>
            </div>
        </div>
    </div>
    
    <!-- Intention Selection Modal -->
    <div class="intention-selection-modal" id="intentionSelectionModal">
        <div class="intention-selection-container">
            <div class="intention-selection-title">Why are you calling?</div>
            <div class="intention-options">
                <div class="intention-option" data-intention="quick">
                    <div class="intention-icon"><i class="fas fa-bolt"></i></div>
                    <div class="intention-text">
                        <div class="intention-title">Quick chat</div>
                        <div class="intention-desc">Just a quick catch-up</div>
                    </div>
                </div>
                <div class="intention-option" data-intention="important">
                    <div class="intention-icon"><i class="fas fa-exclamation-circle"></i></div>
                    <div class="intention-text">
                        <div class="intention-title">Important</div>
                        <div class="intention-desc">Need to discuss something serious</div>
                    </div>
                </div>
                <div class="intention-option" data-intention="emergency">
                    <div class="intention-icon"><i class="fas fa-ambulance"></i></div>
                    <div class="intention-text">
                        <div class="intention-title">Emergency</div>
                        <div class="intention-desc">Urgent help needed</div>
                    </div>
                </div>
                <div class="intention-option" data-intention="checkin">
                    <div class="intention-icon"><i class="fas fa-heart"></i></div>
                    <div class="intention-text">
                        <div class="intention-title">Just checking in</div>
                        <div class="intention-desc">Wanted to see how you're doing</div>
                    </div>
                </div>
                <div class="intention-option" data-intention="work">
                    <div class="intention-icon"><i class="fas fa-briefcase"></i></div>
                    <div class="intention-text">
                        <div class="intention-title">Work-related</div>
                        <div class="intention-desc">Business or project discussion</div>
                    </div>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="notes-btn" id="cancelIntentionBtn" style="flex: 1;">Cancel</button>
                <button class="notes-btn" id="confirmIntentionBtn" style="flex: 1; background-color: var(--primary-color); color: white;">Set Intention</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== BACKEND MIGRATION CHANGES START ====================
        // All Firebase references have been removed and replaced with API calls
        // ========================================================================
        
        // Import settingsManager.js
        const SettingsManager = {
            // Default settings for calls - UPDATED with new features
            defaultSettings: {
                liveReactions: true,
                inCallChat: true,
                sharedWhiteboard: true,
                polls: true,
                sharedNotes: true,
                emotionalContext: true,
                callIntention: true,
                focusMode: false,
                theme: 'light',
                notifications: true,
                notificationSound: true,
                whoCanFriendMe: 'everyone',
                moodVisibility: 'friends',
                callPermissions: 'everyone'
            },
            
            // Initialize settings
            initializeSettings: function() {
                // Load settings from localStorage or use defaults
                const savedSettings = localStorage.getItem('userSettings');
                if (savedSettings) {
                    try {
                        window.userSettings = JSON.parse(savedSettings);
                    } catch (e) {
                        window.userSettings = { ...this.defaultSettings };
                        this.saveSettings();
                    }
                } else {
                    window.userSettings = { ...this.defaultSettings };
                    this.saveSettings();
                }
                
                // Apply settings to UI
                this.applySettings();
                
                // Set up storage event listener for cross-tab synchronization
                window.addEventListener('storage', (event) => {
                    if (event.key === 'userSettings') {
                        try {
                            window.userSettings = JSON.parse(event.newValue);
                            this.applySettings();
                            this.showNotification('Settings updated', 'success');
                        } catch (e) {
                            console.error('Error parsing settings from storage event:', e);
                        }
                    }
                });
                
                console.log('SettingsManager initialized:', window.userSettings);
            },
            
            // Save a single setting
            saveSetting: function(settingName, value) {
                if (!window.userSettings) {
                    window.userSettings = { ...this.defaultSettings };
                }
                
                window.userSettings[settingName] = value;
                this.saveSettings();
                this.applySetting(settingName, value);
                
                // Broadcast to other tabs
                this.broadcastSettingChange(settingName, value);
                
                console.log('Setting saved:', settingName, value);
            },
            
            // Save all settings to localStorage
            saveSettings: function() {
                try {
                    localStorage.setItem('userSettings', JSON.stringify(window.userSettings));
                } catch (e) {
                    console.error('Error saving settings:', e);
                }
            },
            
            // Apply a specific setting
            applySetting: function(settingName, value) {
                const element = document.querySelector(`[data-setting="${settingName}"]`);
                if (element) {
                    if (element.type === 'checkbox') {
                        element.checked = value;
                    } else if (element.type === 'select-one') {
                        element.value = value;
                    } else {
                        element.value = value;
                    }
                }
                
                // Apply visual changes based on setting
                this.applyVisualSetting(settingName, value);
            },
            
            // Apply all settings to UI
            applySettings: function() {
                if (!window.userSettings) return;
                
                // Apply to all settings elements
                document.querySelectorAll('[data-setting]').forEach(element => {
                    const settingName = element.dataset.setting;
                    if (window.userSettings.hasOwnProperty(settingName)) {
                        const value = window.userSettings[settingName];
                        if (element.type === 'checkbox') {
                            element.checked = value;
                        } else if (element.type === 'select-one') {
                            element.value = value;
                        } else {
                            element.value = value;
                        }
                    }
                });
                
                // Apply all visual settings
                Object.keys(window.userSettings).forEach(settingName => {
                    this.applyVisualSetting(settingName, window.userSettings[settingName]);
                });
            },
            
            // Apply visual changes for specific settings
            applyVisualSetting: function(settingName, value) {
                switch(settingName) {
                    case 'theme':
                        this.applyTheme(value);
                        break;
                    case 'liveReactions':
                        this.applyReactionsSetting(value);
                        break;
                    case 'inCallChat':
                        this.applyChatSetting(value);
                        break;
                    case 'sharedWhiteboard':
                        this.applyWhiteboardSetting(value);
                        break;
                    case 'polls':
                        this.applyPollsSetting(value);
                        break;
                    case 'sharedNotes':
                        this.applyNotesSetting(value);
                        break;
                    case 'emotionalContext':
                        this.applyEmotionalContextSetting(value);
                        break;
                    case 'callIntention':
                        this.applyCallIntentionSetting(value);
                        break;
                    case 'focusMode':
                        this.applyFocusModeSetting(value);
                        break;
                }
            },
            
            // Apply theme
            applyTheme: function(theme) {
                document.body.classList.remove('light-theme', 'dark-theme');
                document.body.classList.add(`${theme}-theme`);
                
                if (theme === 'dark') {
                    document.documentElement.style.setProperty('--bg-color', '#1a1a1a');
                    document.documentElement.style.setProperty('--text-primary', '#ffffff');
                    document.documentElement.style.setProperty('--text-secondary', '#b0b3b8');
                    document.documentElement.style.setProperty('--secondary-color', '#2d2d2d');
                    document.documentElement.style.setProperty('--border-color', '#3e4042');
                } else {
                    document.documentElement.style.setProperty('--bg-color', '#ffffff');
                    document.documentElement.style.setProperty('--text-primary', '#050505');
                    document.documentElement.style.setProperty('--text-secondary', '#65676b');
                    document.documentElement.style.setProperty('--secondary-color', '#f0f2f5');
                    document.documentElement.style.setProperty('--border-color', '#dddfe2');
                }
            },
            
            // Apply reactions setting
            applyReactionsSetting: function(enabled) {
                const reactionsContainer = document.getElementById('reactionsContainer');
                if (reactionsContainer) {
                    reactionsContainer.style.display = enabled ? 'flex' : 'none';
                }
            },
            
            // Apply chat setting
            applyChatSetting: function(enabled) {
                const chatTab = document.querySelector('.panel-tab[data-panel="chat"]');
                if (chatTab) {
                    chatTab.style.display = enabled ? 'flex' : 'none';
                }
                
                // If chat is disabled and currently active, switch to participants
                if (!enabled) {
                    const activeTab = document.querySelector('.panel-tab.active');
                    if (activeTab && activeTab.dataset.panel === 'chat') {
                        const participantsTab = document.querySelector('.panel-tab[data-panel="participants"]');
                        if (participantsTab) {
                            participantsTab.click();
                        }
                    }
                }
            },
            
            // Apply whiteboard setting
            applyWhiteboardSetting: function(enabled) {
                const whiteboardTab = document.querySelector('.panel-tab[data-panel="whiteboard"]');
                if (whiteboardTab) {
                    whiteboardTab.style.display = enabled ? 'flex' : 'none';
                }
            },
            
            // Apply polls setting
            applyPollsSetting: function(enabled) {
                const pollsTab = document.querySelector('.panel-tab[data-panel="polls"]');
                if (pollsTab) {
                    pollsTab.style.display = enabled ? 'flex' : 'none';
                }
            },
            
            // Apply notes setting
            applyNotesSetting: function(enabled) {
                const notesTab = document.querySelector('.panel-tab[data-panel="notes"]');
                if (notesTab) {
                    notesTab.style.display = enabled ? 'flex' : 'none';
                }
            },
            
            // NEW: Apply emotional context setting
            applyEmotionalContextSetting: function(enabled) {
                const moodBtn = document.getElementById('moodBtn');
                const emotionalContextDisplay = document.getElementById('emotionalContextDisplay');
                
                if (moodBtn) {
                    moodBtn.style.display = enabled ? 'flex' : 'none';
                }
                
                if (emotionalContextDisplay) {
                    emotionalContextDisplay.style.display = enabled ? 'block' : 'none';
                }
                
                // Update incoming call display
                const incomingContext = document.getElementById('incomingCallEmotionalContext');
                if (incomingContext) {
                    incomingContext.style.display = enabled ? 'block' : 'none';
                }
            },
            
            // NEW: Apply call intention setting
            applyCallIntentionSetting: function(enabled) {
                const intentionBtn = document.getElementById('intentionBtn');
                const callIntentionDisplay = document.getElementById('callIntentionDisplay');
                
                if (intentionBtn) {
                    intentionBtn.style.display = enabled ? 'flex' : 'none';
                }
                
                if (callIntentionDisplay) {
                    callIntentionDisplay.style.display = enabled ? 'inline-flex' : 'none';
                }
            },
            
            // NEW: Apply focus mode setting
            applyFocusModeSetting: function(enabled) {
                const focusModeBtn = document.getElementById('focusModeBtn');
                if (focusModeBtn) {
                    focusModeBtn.style.display = enabled ? 'flex' : 'none';
                }
                
                if (enabled && window.userSettings && window.userSettings.focusMode) {
                    document.body.classList.add('focus-mode');
                } else {
                    document.body.classList.remove('focus-mode');
                }
            },
            
            // Reset settings to defaults
            resetToDefaults: function() {
                window.userSettings = { ...this.defaultSettings };
                this.saveSettings();
                this.applySettings();
                this.showNotification('Settings reset to defaults', 'success');
                console.log('Settings reset to defaults');
            },
            
            // Reset call-specific settings to defaults
            resetCallSettings: function() {
                const callSettings = ['liveReactions', 'inCallChat', 'sharedWhiteboard', 'polls', 'sharedNotes', 'emotionalContext', 'callIntention', 'focusMode'];
                callSettings.forEach(setting => {
                    window.userSettings[setting] = this.defaultSettings[setting];
                });
                this.saveSettings();
                this.applySettings();
                this.showNotification('Call settings reset to defaults', 'success');
                console.log('Call settings reset to defaults');
            },
            
            // Broadcast setting change to other tabs
            broadcastSettingChange: function(settingName, value) {
                try {
                    // Update localStorage to trigger storage event
                    const currentSettings = JSON.parse(localStorage.getItem('userSettings') || '{}');
                    currentSettings[settingName] = value;
                    localStorage.setItem('userSettings', JSON.stringify(currentSettings));
                    
                    // Also dispatch a custom event for same-tab listening
                    window.dispatchEvent(new CustomEvent('settingChanged', {
                        detail: { settingName, value }
                    }));
                } catch (e) {
                    console.error('Error broadcasting setting change:', e);
                }
            },
            
            // Show notification
            showNotification: function(message, type = 'success') {
                // Use existing notification system
                const notificationText = document.getElementById('notificationText');
                const notification = document.getElementById('notification');
                
                if (notificationText && notification) {
                    notificationText.textContent = message;
                    notification.className = 'notification';
                    notification.classList.add(type);
                    notification.classList.add('active');
                    
                    setTimeout(() => {
                        notification.classList.remove('active');
                    }, 3000);
                } else {
                    // Fallback if notification element doesn't exist
                    console.log(`${type}: ${message}`);
                }
            }
        };

        // Global variables
        let currentUser = null;
        let peer = null;
        let localStream = null;
        let remoteStreams = new Map();
        let currentCall = null;
        let callStartTime = null;
        let callInterval = null;
        let isMuted = false;
        let isVideoOff = false;
        let isSpeakerOn = false;
        let isScreenSharing = false;
        let currentCallType = null;
        let callParticipants = [];
        let selectedContacts = [];
        let whiteboardCanvas = null;
        let whiteboardCtx = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pencil';
        let callLink = null;
        let activeCalls = new Map();
        let dataConnections = new Map();
        let reactionsChannel = null;
        let chatChannel = null;
        
        // NEW UNIQUE FEATURES VARIABLES
        let currentMood = 'neutral';
        let currentIntention = 'checkin';
        let callContinuityData = null;
        let lastNavigationContext = null;
        let relationshipMemory = new Map();
        let callNotes = new Map();
        
        // Connection state management
        let isOnline = navigator.onLine;
        let connectionCheckInterval = null;
        
        // Premium subscription management
        let userSubscription = {
            isPremium: false,
            trialDaysLeft: 30,
            maxGroupParticipants: 8,
            subscriptionType: 'free',
            trialStartDate: null,
            paymentHistory: []
        };
        
        // Payment configuration
        const PAYMENT_CONFIG = {
            premiumMonthly: 500, // KES 500 per month
            premiumYearly: 5000, // KES 5000 per year
            mpesaShortcode: '174379',
            mpesaPasskey: 'bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919',
            mpesaCallbackUrl: 'https://yourdomain.com/mpesa-callback'
        };
        
        // DOM Elements
        const callContainer = document.getElementById('callContainer');
        const callSidePanel = document.getElementById('callSidePanel');
        const newCallModal = document.getElementById('newCallModal');
        const incomingCallModal = document.getElementById('incomingCallModal');
        const videoGrid = document.getElementById('videoGrid');
        const notification = document.getElementById('notification');
        const pipContainer = document.getElementById('pipContainer');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsToggle = document.getElementById('settingsToggle');
        const offlineBanner = document.getElementById('offlineBanner');
        const offlineCallPlaceholder = document.getElementById('offlineCallPlaceholder');
        const syncIndicator = document.getElementById('syncIndicator');
        const paymentModal = document.getElementById('paymentModal');
        
        // NEW: Unique features DOM elements
        const privateNotesModal = document.getElementById('privateNotesModal');
        const callSummaryModal = document.getElementById('callSummaryModal');
        const moodSelectionModal = document.getElementById('moodSelectionModal');
        const intentionSelectionModal = document.getElementById('intentionSelectionModal');
        const focusModeBtn = document.getElementById('focusModeBtn');
        const moodBtn = document.getElementById('moodBtn');
        const intentionBtn = document.getElementById('intentionBtn');
        
        // Call sections
        const allCallsSection = document.getElementById('allCallsSection');
        const missedCallsSection = document.getElementById('missedCallsSection');
        const groupCallsSection = document.getElementById('groupCallsSection');
        const allCallsList = document.getElementById('allCallsList');
        const missedCallsList = document.getElementById('missedCallsList');
        const groupCallsList = document.getElementById('groupCallsList');
        
        // Enhanced Cache Management
        const CACHE_VERSION = 'calls_v3';
        const CACHE_KEYS = {
            CALLS_HISTORY: 'calls_history',
            CONTACTS: 'calls_contacts',
            USER_DATA: 'calls_user_data',
            LAST_SYNC: 'calls_last_sync',
            RELATIONSHIP_MEMORY: 'calls_relationship_memory',
            CALL_NOTES: 'calls_private_notes'
        };
        
        // Call initiation from friends.html
        let pendingCallRequest = null;
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
        
        async function initializeApp() {
            // ==================== BACKEND MIGRATION: Initialize with API system ====================
            try {
                // Check if running in iframe for token handling
                if (window !== window.top) {
                    console.log('Running in iframe, checking parent for authentication...');
                    
                    // Listen for authentication messages from parent
                    window.addEventListener('message', async function(event) {
                        if (event.data && event.data.type === 'authToken') {
                            console.log('Received auth token from parent');
                            // Store token for API calls
                            localStorage.setItem('authToken', event.data.token);
                            
                            // Initialize user with token
                            await initializeWithToken(event.data.token);
                        }
                    });
                    
                    // Request token from parent
                    window.parent.postMessage({ type: 'requestAuthToken' }, '*');
                    
                } else {
                    // Not in iframe, check localStorage for token
                    const token = localStorage.getItem('authToken');
                    if (token) {
                        await initializeWithToken(token);
                    } else {
                        // Try to get current user from api.js
                        await initializeWithAPI();
                    }
                }
                
            } catch (error) {
                console.error('Error initializing app:', error);
                // Fallback to offline mode
                initializeOffline();
            }
        }
        
        // ==================== BACKEND MIGRATION: Token-based initialization ====================
        async function initializeWithToken(token) {
            try {
                // Use api.js to get current user with token
                if (window.api && typeof window.api.getCurrentUser === 'function') {
                    const user = await window.api.getCurrentUser();
                    if (user) {
                        currentUser = user;
                        console.log('User authenticated via token:', currentUser.uid);
                        
                        // Cache user for offline use
                        localStorage.setItem('currentUser', JSON.stringify({
                            uid: user.uid,
                            displayName: user.displayName,
                            email: user.email,
                            photoURL: user.photoURL
                        }));
                        
                        await completeInitialization();
                    }
                }
            } catch (error) {
                console.error('Error initializing with token:', error);
                initializeOffline();
            }
        }
        
        // ==================== BACKEND MIGRATION: API-based initialization ====================
        async function initializeWithAPI() {
            try {
                // First try to get user from localStorage for immediate UI
                const cachedUser = localStorage.getItem('currentUser');
                if (cachedUser) {
                    currentUser = JSON.parse(cachedUser);
                    console.log('Using cached user:', currentUser.uid);
                }
                
                // Then try auth from api.js
                if (window.api && typeof window.api.getCurrentUser === 'function') {
                    const user = await window.api.getCurrentUser();
                    if (user) {
                        currentUser = user;
                        console.log('User detected via api:', currentUser.uid);
                        
                        // Cache user for offline use
                        localStorage.setItem('currentUser', JSON.stringify({
                            uid: user.uid,
                            displayName: user.displayName,
                            email: user.email,
                            photoURL: user.photoURL
                        }));
                    }
                }
                
                if (currentUser) {
                    await completeInitialization();
                } else {
                    console.log('No user detected, redirecting to login');
                    // Check if we're in the app.js context
                    if (typeof window !== 'undefined' && window.location.pathname.includes('calls.html')) {
                        window.location.href = 'index.html';
                    }
                }
            } catch (error) {
                console.error('Error checking user via api:', error);
                initializeOffline();
            }
        }
        
        // ==================== BACKEND MIGRATION: Offline initialization ====================
        function initializeOffline() {
            console.log('Initializing in offline mode');
            
            // Try to use cached user
            const cachedUser = localStorage.getItem('currentUser');
            if (cachedUser) {
                try {
                    currentUser = JSON.parse(cachedUser);
                    console.log('Using cached user for offline mode:', currentUser.uid);
                } catch (e) {
                    console.error('Error parsing cached user:', e);
                }
            }
            
            // Initialize settings
            SettingsManager.initializeSettings();
            
            // Initialize connection detection
            initializeConnectionDetection();
            
            // Setup event listeners
            setupEventListeners();
            
            // Initialize UI with offline data
            initializeOfflineUI();
            
            // Update UI for connectivity state
            updateUIForConnectivity();
        }
        
        async function completeInitialization() {
            // Initialize settings manager
            SettingsManager.initializeSettings();
            
            // Initialize connection detection
            initializeConnectionDetection();
            
            // Initialize user data
            await initializeUser();
            await loadUserSubscription();
            
            // Setup event listeners
            setupEventListeners();
            initializeWhiteboard();
            
            // Load calls from cache instantly (fast)
            await loadCallsFromCache();
            
            // Load relationship memory
            await loadRelationshipMemory();
            
            // Fix mobile layout
            fixMobileLayout();
            
            // Listen for external calls from friends.html
            listenForExternalCalls();
            
            // Check for URL parameters for call initiation
            checkUrlForCallInitiation();
            
            // Update UI for connectivity state
            updateUIForConnectivity();
            
            // Check for call continuity data
            checkCallContinuity();
            
            // Start background sync if online
            if (isOnline) {
                startBackgroundSync();
            }
            
            // Initialize PeerJS if online
            if (isOnline) {
                setTimeout(() => {
                    initializePeerJS();
                    setupPresenceTracking();
                }, 1000);
            }
            
            console.log('App initialization complete');
        }
        
        function initializeOfflineUI() {
            // Load calls from cache
            loadCallsFromCache();
            
            // Load relationship memory from cache
            loadRelationshipMemory();
            
            // Fix mobile layout
            fixMobileLayout();
            
            // Update UI for offline state
            updateUIForConnectivity();
            
            // Show call container in view-only mode
            callContainer.classList.add('active');
            document.getElementById('callParticipants').textContent = 'Connection Required';
            document.getElementById('callStatus').textContent = 'Call features require connection';
            offlineCallPlaceholder.style.display = 'flex';
            
            console.log('Offline UI initialized');
        }
        
        function checkUrlForCallInitiation() {
            // Check if URL has call parameters
            const urlParams = new URLSearchParams(window.location.search);
            const callUserId = urlParams.get('call');
            const callType = urlParams.get('type') || 'video';
            
            if (callUserId) {
                console.log('Call initiated via URL:', callUserId, callType);
                
                // Store the pending call request
                pendingCallRequest = {
                    userId: callUserId,
                    type: callType,
                    timestamp: Date.now()
                };
                
                // If we're already initialized with user, start the call immediately
                if (currentUser) {
                    setTimeout(() => {
                        if (isOnline) {
                            startCallFromFriend(callUserId, callType);
                        } else {
                            showNotification('Call features require connection', 'info');
                        }
                    }, 2000);
                }
                
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }
        
        function startCallFromFriend(userId, type = 'video') {
            console.log('Starting call from friend request:', userId, type);
            
            if (!isOnline) {
                showNotification('Call features require connection', 'info');
                return;
            }
            
            if (!currentUser) {
                showNotification('Please login to make calls', 'info');
                return;
            }
            
            // Hide sidebar and show call container immediately
            document.querySelector('.sidebar').style.display = 'none';
            callContainer.classList.add('active');
            
            // Start the call
            startCall(userId, type);
        }
        
        // ==================== BACKEND MIGRATION: Enhanced Cache Management ====================
        async function loadCallsFromCache() {
            console.log('Loading calls from cache...');
            
            try {
                if (!currentUser) {
                    console.log('No user, cannot load calls');
                    return;
                }
                
                const cacheKey = `${CACHE_KEYS.CALLS_HISTORY}_${currentUser.uid}`;
                const cachedCalls = localStorage.getItem(cacheKey);
                
                if (!cachedCalls) {
                    console.log('No cached calls found');
                    allCallsList.innerHTML = `
                        <div class="offline-state">
                            <i class="fas fa-phone"></i>
                            <p>No call history yet</p>
                            <p class="subtext">Make your first call to see history here</p>
                        </div>
                    `;
                    updateSyncIndicator('empty');
                    return;
                }
                
                const calls = JSON.parse(cachedCalls);
                console.log(`Loaded ${calls.length} calls from cache`);
                
                // Display calls immediately
                displayCallsFromCache(calls, allCallsList, 'all');
                
                // Filter and display missed calls
                const missedCalls = calls.filter(call => call.status === 'missed');
                displayCallsFromCache(missedCalls, missedCallsList, 'missed');
                
                // Filter and display group calls
                const groupCalls = calls.filter(call => call.group === true || (call.participants && call.participants.length > 2));
                displayCallsFromCache(groupCalls, groupCallsList, 'group');
                
                updateSyncIndicator('ready', calls.length);
                
            } catch (error) {
                console.error('Error loading calls from cache:', error);
                allCallsList.innerHTML = `
                    <div class="offline-state">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Error loading call history</p>
                        <p class="subtext">Try refreshing the page</p>
                    </div>
                `;
                updateSyncIndicator('error');
            }
        }
        
        function displayCallsFromCache(callsArray, container, type) {
            if (!container) return;
            
            if (!callsArray || callsArray.length === 0) {
                let emptyMessage = '';
                switch(type) {
                    case 'missed':
                        emptyMessage = `
                            <div class="offline-state">
                                <i class="fas fa-phone-slash"></i>
                                <p>No missed calls</p>
                                <p class="subtext">All calls have been answered</p>
                            </div>
                        `;
                        break;
                    case 'group':
                        emptyMessage = `
                            <div class="offline-state">
                                <i class="fas fa-users"></i>
                                <p>No group calls</p>
                                <p class="subtext">Start your first group call</p>
                            </div>
                        `;
                        break;
                    default:
                        emptyMessage = `
                            <div class="offline-state">
                                <i class="fas fa-phone"></i>
                                <p>No recent calls</p>
                                <p class="subtext>Make your first call to see history here</p>
                            </div>
                        `;
                }
                container.innerHTML = emptyMessage;
                return;
            }
            
            container.innerHTML = '';
            
            // Sort by timestamp (newest first)
            callsArray.sort((a, b) => {
                const timeA = a.timestamp?.toDate ? a.timestamp.toDate() : new Date(a.timestamp || a.savedAt);
                const timeB = b.timestamp?.toDate ? b.timestamp.toDate() : new Date(b.timestamp || b.savedAt);
                return timeB - timeA;
            });
            
            // Process each call
            const promises = [];
            callsArray.forEach(callData => {
                promises.push(displayCallItemFromData(callData, container));
            });
            
            Promise.all(promises).catch(error => {
                console.error('Error displaying cached calls:', error);
            });
            
            // Ensure at least 5 items are visible without scrolling
            setTimeout(() => {
                const callItems = container.querySelectorAll('.call-item');
                if (callItems.length > 0) {
                    // Calculate height needed for 5 items
                    const itemHeight = callItems[0].offsetHeight || 80;
                    const minHeight = itemHeight * Math.min(5, callItems.length);
                    container.style.minHeight = minHeight + 'px';
                }
            }, 100);
        }
        
        async function saveCallsToCache(callsArray) {
            try {
                if (!currentUser) return;
                
                const cacheKey = `${CACHE_KEYS.CALLS_HISTORY}_${currentUser.uid}`;
                
                // Get existing cached calls
                const existingCached = localStorage.getItem(cacheKey);
                let existingCalls = [];
                
                if (existingCached) {
                    existingCalls = JSON.parse(existingCached);
                }
                
                // Merge new calls with existing ones
                const mergedCalls = mergeCallsArrays(existingCalls, callsArray);
                
                // Keep only last 100 calls
                const limitedCalls = mergedCalls.slice(0, 100);
                
                // Save to cache
                localStorage.setItem(cacheKey, JSON.stringify(limitedCalls));
                
                // Update last sync time
                localStorage.setItem(`${CACHE_KEYS.LAST_SYNC}_${currentUser.uid}`, new Date().toISOString());
                
                console.log(`Saved ${limitedCalls.length} calls to cache`);
                return limitedCalls.length;
                
            } catch (error) {
                console.error('Error saving calls to cache:', error);
                return 0;
            }
        }
        
        function mergeCallsArrays(existingCalls, newCalls) {
            const callMap = new Map();
            
            // Add existing calls to map
            existingCalls.forEach(call => {
                const key = call.id || `local_${call.savedAt}`;
                callMap.set(key, call);
            });
            
            // Add or update with new calls
            newCalls.forEach(call => {
                const key = call.id || `local_${call.savedAt}`;
                const existingCall = callMap.get(key);
                
                if (existingCall) {
                    // Merge data, preferring newer timestamps
                    const existingTime = existingCall.timestamp?.toDate ? 
                        existingCall.timestamp.toDate() : new Date(existingCall.timestamp || existingCall.savedAt);
                    const newTime = call.timestamp?.toDate ? 
                        call.timestamp.toDate() : new Date(call.timestamp || call.savedAt);
                    
                    if (newTime > existingTime) {
                        callMap.set(key, call);
                    }
                } else {
                    callMap.set(key, call);
                }
            });
            
            // Convert map back to array
            return Array.from(callMap.values());
        }
        
        function updateSyncIndicator(status, count = 0) {
            if (!syncIndicator) return;
            
            switch(status) {
                case 'syncing':
                    syncIndicator.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> Syncing...';
                    syncIndicator.className = 'sync-indicator syncing';
                    break;
                case 'ready':
                    syncIndicator.innerHTML = `<i class="fas fa-check-circle"></i> ${count} calls`;
                    syncIndicator.className = 'sync-indicator';
                    break;
                case 'online':
                    syncIndicator.innerHTML = '<i class="fas fa-wifi"></i> Live';
                    syncIndicator.className = 'sync-indicator syncing';
                    break;
                case 'offline':
                    syncIndicator.innerHTML = '<i class="fas fa-wifi-slash"></i> Offline';
                    syncIndicator.className = 'sync-indicator';
                    break;
                case 'empty':
                    syncIndicator.innerHTML = '<i class="fas fa-database"></i> No data';
                    syncIndicator.className = 'sync-indicator';
                    break;
                case 'error':
                    syncIndicator.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Error';
                    syncIndicator.className = 'sync-indicator';
                    break;
            }
        }
        
        async function startBackgroundSync() {
            if (!isOnline || !currentUser) {
                console.log('Cannot start background sync: offline or no user');
                return;
            }
            
            console.log('Starting background sync...');
            updateSyncIndicator('syncing');
            
            try {
                // ==================== BACKEND MIGRATION: Use API instead of Firebase ====================
                if (window.api && typeof window.api.get === 'function') {
                    const response = await window.api.get('/api/calls/history', {
                        params: {
                            userId: currentUser.uid,
                            limit: 50,
                            orderBy: 'timestamp',
                            order: 'desc'
                        }
                    });
                    
                    if (response && response.data) {
                        const callsToSave = response.data.map(call => ({
                            ...call,
                            id: call._id || call.id,
                            timestamp: call.timestamp || call.createdAt,
                            isLocal: false
                        }));
                        
                        // Save to cache
                        const savedCount = await saveCallsToCache(callsToSave);
                        
                        // Update UI with merged data
                        if (savedCount > 0) {
                            // Reload from cache to show merged data
                            await loadCallsFromCache();
                            
                            // Show subtle notification
                            if (response.data.length > 0) {
                                showNotification(`Synced ${response.data.length} calls`, 'success');
                            }
                        }
                        
                        updateSyncIndicator('online', savedCount);
                    }
                }
                
            } catch (error) {
                console.error('Background sync error:', error);
                updateSyncIndicator('ready', 0);
                
                // Don't show error notification for background sync failures
                // Just log it and continue with cached data
            }
        }
        
        // ==================== NEW UNIQUE FEATURE: Call Continuity ====================
        function checkCallContinuity() {
            const continuityData = localStorage.getItem('callContinuityData');
            if (continuityData) {
                try {
                    callContinuityData = JSON.parse(continuityData);
                    console.log('Found call continuity data:', callContinuityData);
                    
                    // Check if call was active less than 5 minutes ago
                    const now = Date.now();
                    const lastActive = callContinuityData.timestamp;
                    const fiveMinutes = 5 * 60 * 1000;
                    
                    if (now - lastActive < fiveMinutes) {
                        showNotification('Resuming previous call session...', 'info');
                        
                        // Restore call state
                        if (callContinuityData.active) {
                            // Show call container
                            callContainer.classList.add('active');
                            document.querySelector('.sidebar').style.display = 'none';
                            
                            // Restore call info
                            document.getElementById('callParticipants').textContent = callContinuityData.participants || 'Previous Call';
                            document.getElementById('callStatus').textContent = 'Reconnecting...';
                            document.getElementById('callDuration').textContent = callContinuityData.duration || '00:00';
                            
                            // Show connecting state
                            offlineCallPlaceholder.style.display = 'none';
                            
                            // Attempt to reconnect if online
                            if (isOnline && callContinuityData.targetId) {
                                setTimeout(() => {
                                    startCall(callContinuityData.targetId, callContinuityData.type || 'video');
                                }, 1000);
                            }
                        }
                    }
                    
                    // Clear continuity data after checking
                    localStorage.removeItem('callContinuityData');
                    
                } catch (error) {
                    console.error('Error parsing call continuity data:', error);
                    localStorage.removeItem('callContinuityData');
                }
            }
        }
        
        function saveCallContinuity() {
            if (!currentCall) return;
            
            const continuityData = {
                active: true,
                timestamp: Date.now(),
                targetId: currentCall.targetId,
                type: currentCallType,
                participants: document.getElementById('callParticipants').textContent,
                duration: document.getElementById('callDuration').textContent,
                startTime: callStartTime ? callStartTime.getTime() : null
            };
            
            localStorage.setItem('callContinuityData', JSON.stringify(continuityData));
            console.log('Call continuity data saved');
        }
        
        // ==================== NEW UNIQUE FEATURE: Emotional Context ====================
        function showMoodSelection() {
            if (!window.userSettings || !window.userSettings.emotionalContext) {
                showNotification('Emotional context is disabled in settings', 'info');
                return;
            }
            
            // Reset selection
            document.querySelectorAll('.mood-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Select current mood if exists
            const currentMoodOption = document.querySelector(`.mood-option[data-mood="${currentMood}"]`);
            if (currentMoodOption) {
                currentMoodOption.classList.add('selected');
            }
            
            // Show modal
            moodSelectionModal.classList.add('active');
        }
        
        function setMood(mood) {
            currentMood = mood;
            
            // Update UI
            const moodDisplay = document.getElementById('callMoodDisplay');
            const moodText = document.getElementById('moodText');
            
            if (moodDisplay && moodText) {
                // Remove all mood classes
                moodDisplay.className = 'mood-indicator';
                
                // Add appropriate mood class
                switch(mood) {
                    case 'happy':
                        moodDisplay.classList.add('mood-happy');
                        moodText.textContent = 'Happy';
                        break;
                    case 'neutral':
                        moodDisplay.classList.add('mood-neutral');
                        moodText.textContent = 'Neutral';
                        break;
                    case 'sad':
                        moodDisplay.classList.add('mood-sad');
                        moodText.textContent = 'Sad';
                        break;
                    case 'angry':
                        moodDisplay.classList.add('mood-angry');
                        moodText.textContent = 'Angry';
                        break;
                    case 'tired':
                        moodDisplay.classList.add('mood-tired');
                        moodText.textContent = 'Tired';
                        break;
                    case 'excited':
                        moodDisplay.classList.add('mood-happy'); // Use happy style for excited
                        moodText.textContent = 'Excited';
                        break;
                }
            }
            
            // Broadcast mood to other participants if in a call
            if (currentCall && isOnline) {
                broadcastDataMessage({
                    type: 'mood',
                    mood: mood,
                    userId: currentUser.uid,
                    timestamp: new Date().toISOString()
                });
            }
            
            showNotification(`Mood set to: ${mood}`, 'success');
            moodSelectionModal.classList.remove('active');
        }
        
        // ==================== NEW UNIQUE FEATURE: Call Intention ====================
        function showIntentionSelection() {
            if (!window.userSettings || !window.userSettings.callIntention) {
                showNotification('Call intention is disabled in settings', 'info');
                return;
            }
            
            // Reset selection
            document.querySelectorAll('.intention-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Select current intention if exists
            const currentIntentionOption = document.querySelector(`.intention-option[data-intention="${currentIntention}"]`);
            if (currentIntentionOption) {
                currentIntentionOption.classList.add('selected');
            }
            
            // Show modal
            intentionSelectionModal.classList.add('active');
        }
        
        function setIntention(intention) {
            currentIntention = intention;
            
            // Update UI
            const intentionDisplay = document.getElementById('callIntentionDisplay');
            const intentionText = document.getElementById('intentionText');
            
            if (intentionDisplay && intentionText) {
                // Remove all intention classes
                intentionDisplay.className = 'intention-indicator';
                
                // Add appropriate intention class and text
                switch(intention) {
                    case 'quick':
                        intentionDisplay.classList.add('intention-quick');
                        intentionText.textContent = 'Quick chat';
                        break;
                    case 'important':
                        intentionDisplay.classList.add('intention-important');
                        intentionText.textContent = 'Important';
                        break;
                    case 'emergency':
                        intentionDisplay.classList.add('intention-emergency');
                        intentionText.textContent = 'Emergency';
                        break;
                    case 'checkin':
                        intentionDisplay.classList.add('intention-checkin');
                        intentionText.textContent = 'Just checking in';
                        break;
                    case 'work':
                        intentionDisplay.classList.add('intention-work');
                        intentionText.textContent = 'Work-related';
                        break;
                }
                
                // Show intention display
                intentionDisplay.style.display = 'inline-flex';
            }
            
            // Broadcast intention to other participants if in a call
            if (currentCall && isOnline) {
                broadcastDataMessage({
                    type: 'intention',
                    intention: intention,
                    userId: currentUser.uid,
                    timestamp: new Date().toISOString()
                });
            }
            
            showNotification(`Call intention set: ${intention}`, 'success');
            intentionSelectionModal.classList.remove('active');
        }
        
        // ==================== NEW UNIQUE FEATURE: Private Call Notes ====================
        function showPrivateNotesModal() {
            privateNotesModal.classList.add('active');
            
            // Load previous notes if any
            if (currentCall && currentCall.targetId) {
                const noteKey = `call_note_${currentCall.targetId}_${currentCall.startTime?.getTime() || Date.now()}`;
                const savedNote = localStorage.getItem(noteKey);
                if (savedNote) {
                    document.getElementById('privateNotesTextarea').value = savedNote;
                }
            }
        }
        
        async function savePrivateNotes() {
            const notes = document.getElementById('privateNotesTextarea').value.trim();
            
            if (!currentCall) return;
            
            // Save notes to localStorage
            if (currentCall.targetId) {
                const noteKey = `call_note_${currentCall.targetId}_${currentCall.startTime?.getTime() || Date.now()}`;
                localStorage.setItem(noteKey, notes);
                
                // Also save to call notes map for current session
                callNotes.set(currentCall.targetId, {
                    notes: notes,
                    timestamp: new Date().toISOString(),
                    callId: currentCall.callId
                });
            }
            
            // ==================== BACKEND MIGRATION: Save to backend if online ====================
            if (isOnline && window.api && typeof window.api.post === 'function') {
                try {
                    await window.api.post('/api/calls/notes', {
                        userId: currentUser.uid,
                        targetId: currentCall.targetId,
                        notes: notes,
                        callId: currentCall.callId,
                        timestamp: new Date().toISOString()
                    });
                } catch (error) {
                    console.error('Error saving notes to backend:', error);
                }
            }
            
            showNotification('Private notes saved', 'success');
            privateNotesModal.classList.remove('active');
        }
        
        // ==================== NEW UNIQUE FEATURE: Call Summary Snapshot ====================
        function showCallSummary() {
            if (!currentCall) return;
            
            // Calculate duration
            let duration = '00:00';
            if (callStartTime) {
                const endTime = new Date();
                const diffMs = endTime - callStartTime;
                const minutes = Math.floor(diffMs / 60000);
                const seconds = Math.floor((diffMs % 60000) / 1000);
                duration = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update summary elements
            document.getElementById('summaryDuration').textContent = duration;
            document.getElementById('summaryTime').textContent = formatTimeAgo(new Date());
            document.getElementById('summaryType').textContent = currentCallType === 'video' ? 'Video Call' : 'Voice Call';
            document.getElementById('summaryMood').textContent = currentMood.charAt(0).toUpperCase() + currentMood.slice(1);
            document.getElementById('summaryIntention').textContent = 
                currentIntention === 'checkin' ? 'Just checking in' : 
                currentIntention === 'quick' ? 'Quick chat' :
                currentIntention === 'important' ? 'Important' :
                currentIntention === 'emergency' ? 'Emergency' :
                currentIntention === 'work' ? 'Work-related' : 'Unknown';
            document.getElementById('summaryParticipants').textContent = callParticipants.length;
            
            // Show modal
            callSummaryModal.classList.add('active');
        }
        
        // ==================== NEW UNIQUE FEATURE: Smart Call Return ====================
        function smartReturnAfterCall() {
            // Check where user came from
            const lastContext = localStorage.getItem('lastNavigationContext');
            
            if (lastContext) {
                try {
                    const context = JSON.parse(lastContext);
                    const now = Date.now();
                    const fiveMinutes = 5 * 60 * 1000;
                    
                    // Only return if context is recent (less than 5 minutes ago)
                    if (now - context.timestamp < fiveMinutes) {
                        switch(context.page) {
                            case 'friends':
                                // Navigate back to friends page
                                if (window !== window.top) {
                                    // In iframe, send message to parent
                                    window.parent.postMessage({ type: 'navigate', page: 'friends' }, '*');
                                } else {
                                    window.location.href = 'friends.html';
                                }
                                return;
                            case 'chat':
                                // Navigate back to chat
                                if (window !== window.top) {
                                    window.parent.postMessage({ 
                                        type: 'navigate', 
                                        page: 'chat',
                                        userId: context.userId 
                                    }, '*');
                                }
                                return;
                            case 'groups':
                                // Navigate back to groups
                                if (window !== window.top) {
                                    window.parent.postMessage({ type: 'navigate', page: 'groups' }, '*');
                                }
                                return;
                        }
                    }
                } catch (error) {
                    console.error('Error parsing navigation context:', error);
                }
            }
            
            // Default: Stay on calls page
            localStorage.setItem('lastNavigationContext', JSON.stringify({
                page: 'calls',
                timestamp: Date.now()
            }));
        }
        
        // ==================== NEW UNIQUE FEATURE: Relationship Memory ====================
        async function loadRelationshipMemory() {
            try {
                if (!currentUser) return;
                
                const cacheKey = `${CACHE_KEYS.RELATIONSHIP_MEMORY}_${currentUser.uid}`;
                const cachedMemory = localStorage.getItem(cacheKey);
                
                if (cachedMemory) {
                    const memoryData = JSON.parse(cachedMemory);
                    relationshipMemory = new Map(Object.entries(memoryData));
                    console.log('Loaded relationship memory from cache:', relationshipMemory.size, 'contacts');
                }
                
                // ==================== BACKEND MIGRATION: Load from backend if online ====================
                if (isOnline && window.api && typeof window.api.get === 'function') {
                    try {
                        const response = await window.api.get(`/api/users/${currentUser.uid}/relationship-memory`);
                        if (response && response.data) {
                            relationshipMemory = new Map(Object.entries(response.data));
                            
                            // Save to cache
                            localStorage.setItem(cacheKey, JSON.stringify(Object.fromEntries(relationshipMemory)));
                        }
                    } catch (error) {
                        console.error('Error loading relationship memory from backend:', error);
                    }
                }
                
            } catch (error) {
                console.error('Error loading relationship memory:', error);
            }
        }
        
        function updateRelationshipMemory(userId, callData) {
            if (!userId || userId === currentUser.uid) return;
            
            const now = new Date();
            const today = now.toDateString();
            
            if (!relationshipMemory.has(userId)) {
                relationshipMemory.set(userId, {
                    totalCalls: 0,
                    lastCall: now,
                    firstCall: now,
                    callHistory: [],
                    moods: {},
                    intentions: {}
                });
            }
            
            const userMemory = relationshipMemory.get(userId);
            userMemory.totalCalls++;
            userMemory.lastCall = now;
            
            // Add to call history (limit to last 20 calls)
            userMemory.callHistory.unshift({
                timestamp: now,
                type: callData.type,
                duration: callData.duration,
                mood: callData.mood,
                intention: callData.intention
            });
            
            if (userMemory.callHistory.length > 20) {
                userMemory.callHistory = userMemory.callHistory.slice(0, 20);
            }
            
            // Track mood frequency
            if (callData.mood) {
                userMemory.moods[callData.mood] = (userMemory.moods[callData.mood] || 0) + 1;
            }
            
            // Track intention frequency
            if (callData.intention) {
                userMemory.intentions[callData.intention] = (userMemory.intentions[callData.intention] || 0) + 1;
            }
            
            // Save to cache
            const cacheKey = `${CACHE_KEYS.RELATIONSHIP_MEMORY}_${currentUser.uid}`;
            localStorage.setItem(cacheKey, JSON.stringify(Object.fromEntries(relationshipMemory)));
            
            // ==================== BACKEND MIGRATION: Save to backend if online ====================
            if (isOnline && window.api && typeof window.api.post === 'function') {
                try {
                    window.api.post(`/api/users/${currentUser.uid}/relationship-memory`, {
                        targetId: userId,
                        memory: userMemory
                    }).catch(error => {
                        console.error('Error saving relationship memory to backend:', error);
                    });
                } catch (error) {
                    console.error('Error saving relationship memory:', error);
                }
            }
        }
        
        function getRelationshipInsights(userId) {
            if (!relationshipMemory.has(userId)) {
                return {
                    frequency: 'First call',
                    lastCall: null,
                    totalCalls: 0,
                    commonMood: null,
                    commonIntention: null
                };
            }
            
            const memory = relationshipMemory.get(userId);
            const now = new Date();
            const lastCall = new Date(memory.lastCall);
            const daysSinceLastCall = Math.floor((now - lastCall) / (1000 * 60 * 60 * 24));
            
            let frequency = 'First call';
            if (memory.totalCalls > 10) {
                frequency = 'Frequent contact';
            } else if (memory.totalCalls > 3) {
                frequency = 'Regular contact';
            } else if (memory.totalCalls > 1) {
                frequency = 'Occasional contact';
            }
            
            // Find most common mood
            let commonMood = null;
            let maxMoodCount = 0;
            for (const [mood, count] of Object.entries(memory.moods)) {
                if (count > maxMoodCount) {
                    maxMoodCount = count;
                    commonMood = mood;
                }
            }
            
            // Find most common intention
            let commonIntention = null;
            let maxIntentionCount = 0;
            for (const [intention, count] of Object.entries(memory.intentions)) {
                if (count > maxIntentionCount) {
                    maxIntentionCount = count;
                    commonIntention = intention;
                }
            }
            
            return {
                frequency: frequency,
                lastCall: daysSinceLastCall,
                totalCalls: memory.totalCalls,
                commonMood: commonMood,
                commonIntention: commonIntention
            };
        }
        
        // ==================== NEW UNIQUE FEATURE: Focus Mode ====================
        function toggleFocusMode() {
            document.body.classList.toggle('focus-mode');
            
            const isActive = document.body.classList.contains('focus-mode');
            const icon = focusModeBtn.querySelector('i');
            
            if (isActive) {
                icon.className = 'fas fa-eye-slash';
                showNotification('Focus mode enabled', 'success');
            } else {
                icon.className = 'fas fa-eye';
                showNotification('Focus mode disabled', 'success');
            }
            
            // Save to settings
            if (window.userSettings) {
                window.userSettings.focusMode = isActive;
                SettingsManager.saveSettings();
            }
        }
        
        function fixMobileLayout() {
            if (window.innerWidth <= 768) {
                // Ensure sections display properly on mobile
                const activeSection = document.querySelector('.calls-section.active');
                if (activeSection) {
                    activeSection.style.display = 'flex';
                    activeSection.style.flex = '1';
                }
                
                // Ensure call list is visible
                const callsList = document.querySelector('.calls-list');
                if (callsList) {
                    callsList.style.display = 'flex';
                    callsList.style.flexDirection = 'column';
                    callsList.style.minHeight = '250px';
                }
                
                // Adjust sidebar height for better visibility
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) {
                    const windowHeight = window.innerHeight;
                    const availableHeight = Math.min(windowHeight * 0.7, windowHeight - 100);
                    sidebar.style.maxHeight = availableHeight + 'px';
                }
            }
        }
        
        function initializeConnectionDetection() {
            // Check initial online status
            updateConnectionStatus();
            
            // Listen for online/offline events
            window.addEventListener('online', handleOnline);
            window.addEventListener('offline', handleOffline);
            
            // Start periodic connectivity check
            connectionCheckInterval = setInterval(checkConnectivity, 30000);
            
            // Initial UI update
            updateUIForConnectivity();
        }
        
        function updateConnectionStatus() {
            isOnline = navigator.onLine;
            console.log('Network status:', isOnline ? 'Online' : 'Offline');
        }
        
        function handleOnline() {
            console.log('App is now online');
            isOnline = true;
            updateUIForConnectivity();
            
            // Update sync indicator
            updateSyncIndicator('syncing');
            
            // Start background sync
            setTimeout(() => {
                startBackgroundSync();
            }, 1000);
            
            // Try to reinitialize PeerJS when network is restored
            if (!peer && currentUser) {
                setTimeout(() => {
                    initializePeerJS();
                }, 2000);
            }
            
            // Show notification
            showNotification('Connected. Syncing call history...', 'success');
            
            // Update user presence
            if (currentUser) {
                updateUserPresence(true);
            }
            
            // Remove offline UI state
            document.body.classList.remove('offline-ui');
            
            // Hide offline placeholder if showing
            if (offlineCallPlaceholder.style.display !== 'none') {
                offlineCallPlaceholder.style.display = 'none';
            }
            
            // Update subscription info
            if (currentUser) {
                loadUserSubscription();
            }
            
            // Process any pending call request
            if (pendingCallRequest) {
                setTimeout(() => {
                    startCallFromFriend(pendingCallRequest.userId, pendingCallRequest.type);
                    pendingCallRequest = null;
                }, 1000);
            }
            
            // ==================== BACKEND MIGRATION: Sync data with backend ====================
            syncOfflineData();
        }
        
        function handleOffline() {
            console.log('App is now offline');
            isOnline = false;
            updateUIForConnectivity();
            
            // Update sync indicator
            updateSyncIndicator('offline');
            
            // Show notification
            showNotification('Connection lost. Using local data.', 'warning');

            // End any active calls gracefully
            if (currentCall) {
                // Save call continuity data before ending
                saveCallContinuity();
                endCall();
            }
            
            // Update user presence
            if (currentUser) {
                updateUserPresence(false);
            }
            
            // Add offline UI state for visual indication
            document.body.classList.add('offline-ui');
            
            // Show offline placeholder in video grid if call container is active
            if (callContainer.classList.contains('active')) {
                offlineCallPlaceholder.style.display = 'flex';
            }
        }
        
        // ==================== BACKEND MIGRATION: Sync offline data when back online ====================
        async function syncOfflineData() {
            if (!isOnline || !currentUser) return;
            
            try {
                // Sync call notes
                const notesToSync = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('call_note_')) {
                        const note = localStorage.getItem(key);
                        const parts = key.split('_');
                        const targetId = parts[2];
                        const timestamp = parts[3];
                        
                        notesToSync.push({
                            targetId: targetId,
                            notes: note,
                            timestamp: timestamp
                        });
                    }
                }
                
                if (notesToSync.length > 0 && window.api && typeof window.api.post === 'function') {
                    await window.api.post('/api/calls/sync-notes', {
                        userId: currentUser.uid,
                        notes: notesToSync
                    });
                    console.log(`Synced ${notesToSync.length} call notes`);
                }
                
                // Sync relationship memory
                const cacheKey = `${CACHE_KEYS.RELATIONSHIP_MEMORY}_${currentUser.uid}`;
                const cachedMemory = localStorage.getItem(cacheKey);
                if (cachedMemory && window.api && typeof window.api.post === 'function') {
                    await window.api.post(`/api/users/${currentUser.uid}/sync-relationship-memory`, {
                        memory: JSON.parse(cachedMemory)
                    });
                    console.log('Synced relationship memory');
                }
                
            } catch (error) {
                console.error('Error syncing offline data:', error);
            }
        }
        
        async function updateUserPresence(online) {
            try {
                // ==================== BACKEND MIGRATION: Use API instead of Firebase ====================
                if (window.api && typeof window.api.post === 'function' && currentUser) {
                    await window.api.post('/api/users/presence', {
                        userId: currentUser.uid,
                        online: online,
                        lastOnline: new Date().toISOString()
                    });
                }
            } catch (error) {
                console.error('Error updating user presence:', error);
            }
        }
        
        function checkConnectivity() {
            // Simple connectivity check
            if (navigator.onLine !== isOnline) {
                if (navigator.onLine) {
                    handleOnline();
                } else {
                    handleOffline();
                }
            }
        }
        
        function updateUIForConnectivity() {
            if (!isOnline) {
                // Show offline banner
                offlineBanner.classList.add('active');
                offlineBanner.innerHTML = `
                    <i class="fas fa-wifi-slash"></i>
                    <span>Connection lost. Using local data.</span>
                `;
                
                // Disable call buttons when offline
                const callButtons = [
                    'newCallBtn',
                    'voiceCallBtn',
                    'videoCallBtn',
                    'groupCallBtn',
                    'startCallBtn',
                    'createVoiceLinkBtn',
                    'createVideoLinkBtn',
                    'addParticipantsBtn'
                ];
                
                callButtons.forEach(buttonId => {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        button.disabled = true;
                        button.title = 'Call features require connection';
                    }
                });
                
                // Disable call-back buttons in call history
                const callbackButtons = document.querySelectorAll('.call-action-btn');
                callbackButtons.forEach(button => {
                    button.disabled = true;
                    button.title = 'Call features require connection';
                });
                
                // Disable contact checkboxes in new call modal
                const contactCheckboxes = document.querySelectorAll('.contact-checkbox');
                contactCheckboxes.forEach(checkbox => {
                    checkbox.disabled = true;
                });
                
                // Close new call modal if open
                if (newCallModal.classList.contains('active')) {
                    newCallModal.classList.remove('active');
                    showNotification('Call features require connection', 'warning');
                }
                
                // Close incoming call modal if open
                if (incomingCallModal.classList.contains('active')) {
                    incomingCallModal.classList.remove('active');
                    showNotification('Cannot accept calls while offline', 'warning');
                }
                
                // Close payment modal if open
                if (paymentModal.classList.contains('active')) {
                    paymentModal.classList.remove('active');
                    showNotification('Payment requires connection', 'warning');
                }
                
                // Disable panel tabs that require internet
                const panelTabs = document.querySelectorAll('.panel-tab');
                panelTabs.forEach(tab => {
                    if (tab.dataset.panel !== 'participants') {
                        tab.disabled = true;
                        tab.title = 'Feature unavailable offline';
                    }
                });
                
                // Update call status to show offline state
                if (callContainer.classList.contains('active')) {
                    document.getElementById('callParticipants').textContent = 'Connection Required';
                    document.getElementById('callStatus').textContent = 'Call features require connection';
                    offlineCallPlaceholder.style.display = 'flex';
                }
                
                // Update contacts list to show offline message
                updateContactsForOffline();
                
            } else {
                // Hide offline banner
                offlineBanner.classList.remove('active');
                
                // Enable call buttons when online
                const callButtons = [
                    'newCallBtn',
                    'voiceCallBtn',
                    'videoCallBtn',
                    'groupCallBtn',
                    'startCallBtn',
                    'createVoiceLinkBtn',
                    'createVideoLinkBtn',
                    'addParticipantsBtn'
                ];
                
                callButtons.forEach(buttonId => {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        button.disabled = false;
                        button.title = button.getAttribute('data-original-title') || '';
                    }
                });
                
                // Enable call-back buttons in call history
                const callbackButtons = document.querySelectorAll('.call-action-btn');
                callbackButtons.forEach(button => {
                    button.disabled = false;
                    button.title = 'Call Back';
                });
                
                // Enable contact checkboxes
                const contactCheckboxes = document.querySelectorAll('.contact-checkbox');
                contactCheckboxes.forEach(checkbox => {
                    checkbox.disabled = false;
                });
                
                // Enable panel tabs
                const panelTabs = document.querySelectorAll('.panel-tab');
                panelTabs.forEach(tab => {
                    tab.disabled = false;
                    tab.title = '';
                });
                
                // Remove offline UI state
                document.body.classList.remove('offline-ui');
                
                // Hide offline placeholder
                offlineCallPlaceholder.style.display = 'none';
                
                // Update call status if in call
                if (callContainer.classList.contains('active') && !currentCall) {
                    document.getElementById('callParticipants').textContent = 'Ready to call';
                    document.getElementById('callStatus').textContent = 'Start a new call or wait for incoming calls';
                }
            }
        }
        
        function updateContactsForOffline() {
            const contactsList = document.getElementById('contactsList');
            const groupContactsList = document.getElementById('groupContactsList');
            
            if (contactsList && contactsList.innerHTML.includes('Loading contacts')) {
                contactsList.innerHTML = `
                    <div class="offline-contacts-message">
                        <i class="fas fa-wifi-slash"></i>
                        <p>Contacts unavailable while offline</p>
                        <p class="subtext">Call features require connection</p>
                    </div>
                `;
            }
            
            if (groupContactsList && groupContactsList.innerHTML.includes('Loading contacts')) {
                groupContactsList.innerHTML = `
                    <div class="offline-contacts-message">
                        <i class="fas fa-wifi-slash"></i>
                        <p>Contacts unavailable while offline</p>
                        <p class="subtext">Call features require connection</p>
                    </div>
                `;
            }
        }
        
        // Enhanced localStorage management for calls
        function getLocalStorageKey(key) {
            return currentUser ? `calls_${currentUser.uid}_${key}` : `calls_${key}`;
        }
        
        // Save calls to local storage with better structure
        async function saveCallToLocalStorage(callData) {
            try {
                if (!currentUser) return null;
                
                const enhancedCallData = { ...callData };
                
                if (enhancedCallData.participants && !enhancedCallData.displayName) {
                    const otherParticipants = enhancedCallData.participants.filter(id => id !== currentUser.uid);
                    if (otherParticipants.length === 1) {
                        // Try to get real name from cache
                        const contactName = await getContactNameWithFallback(otherParticipants[0]);
                        enhancedCallData.displayName = contactName || 'Contact';
                    }
                }
                
                // Add emotional context data if available
                if (currentMood) {
                    enhancedCallData.mood = currentMood;
                }
                
                if (currentIntention) {
                    enhancedCallData.intention = currentIntention;
                }
                
                const storageKey = getLocalStorageKey('history');
                const storedCalls = localStorage.getItem(storageKey);
                let calls = [];
                
                if (storedCalls) {
                    calls = JSON.parse(storedCalls);
                }
                
                // Add new call with unique ID
                const callWithId = {
                    ...enhancedCallData,
                    id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    savedAt: new Date().toISOString(),
                    isLocal: true
                };
                
                // Remove any existing call with same ID
                calls = calls.filter(call => call.id !== callWithId.id);
                
                // Add new call to beginning
                calls.unshift(callWithId);
                
                // Keep only last 100 calls
                if (calls.length > 100) {
                    calls = calls.slice(0, 100);
                }
                
                localStorage.setItem(storageKey, JSON.stringify(calls));
                console.log('Call saved to local storage:', callWithId.id);
                
                // Update cache
                await saveCallsToCache(calls);
                
                // Update relationship memory
                if (callWithId.participants) {
                    const otherParticipants = callWithId.participants.filter(id => id !== currentUser.uid);
                    otherParticipants.forEach(userId => {
                        updateRelationshipMemory(userId, callWithId);
                    });
                }
                
                // Update UI if we're on the calls page
                if (window.location.pathname.includes('calls.html')) {
                    loadCallsFromCache();
                }
                
                return callWithId.id;
                
            } catch (error) {
                console.error('Error saving call to local storage:', error);
                return null;
            }
        }
        
        // Get contact name with fallback to backend
        async function getContactNameWithFallback(userId) {
            if (!userId || userId === currentUser.uid) return 'You';
            
            // Try multiple sources in order
            const sources = [
                () => localStorage.getItem(`userInfo_${userId}_displayName`),
                () => localStorage.getItem(`contact_${userId}_name`),
                () => localStorage.getItem(`friend_${userId}_name`),
                async () => {
                    if (isOnline && window.api && typeof window.api.get === 'function') {
                        try {
                            const response = await window.api.get(`/api/users/${userId}`);
                            if (response && response.data) {
                                const userData = response.data;
                                localStorage.setItem(`userInfo_${userId}_displayName`, userData.displayName || 'Contact');
                                if (userData.photoURL) {
                                    localStorage.setItem(`userInfo_${userId}_photoURL`, userData.photoURL);
                                }
                                return userData.displayName || 'Contact';
                            }
                        } catch (error) {
                            console.error('Error fetching user from backend:', error);
                        }
                    }
                    return null;
                }
            ];
            
            for (const source of sources) {
                try {
                    const result = typeof source === 'function' ? await source() : source;
                    if (result && result !== 'Contact' && result !== 'Unknown') {
                        return result;
                    }
                } catch (error) {
                    console.error('Error getting contact name:', error);
                }
            }
            
            return 'Contact';
        }
        
        // Display call item from data (enhanced for offline mode)
        async function displayCallItemFromData(callData, container) {
            // Get contact names with better logic
            let displayName = callData.displayName || 'Contact';
            let otherParticipantIds = [];
            
            if (callData.participants) {
                otherParticipantIds = callData.participants.filter(id => 
                    id !== (currentUser ? currentUser.uid : 'user1')
                );
                
                // If displayName is still generic, try to get proper names
                if (!displayName || displayName === 'Contact' || displayName === 'Unknown') {
                    if (otherParticipantIds.length === 1) {
                        // Use our improved function to get the name
                        displayName = await getContactNameWithFallback(otherParticipantIds[0]);
                    } else if (otherParticipantIds.length > 1) {
                        displayName = `Group Call (${callData.participants.length})`;
                    }
                }
            }
            
            const isGroupCall = callData.group === true || (callData.participants && callData.participants.length > 2);
            const callType = callData.type || 'voice';
            const callStatus = callData.status || 'completed';
            const isMissed = callStatus === 'missed';
            const isOutgoing = callData.initiator === (currentUser ? currentUser.uid : 'user1');
            
            let callTime = 'Recently';
            if (callData.timestamp) {
                const timestamp = typeof callData.timestamp === 'string' ? 
                    new Date(callData.timestamp) : 
                    (callData.timestamp.toDate ? callData.timestamp.toDate() : new Date(callData.timestamp));
                callTime = formatTimeAgo(timestamp);
            } else if (callData.savedAt) {
                callTime = formatTimeAgo(new Date(callData.savedAt));
            }
            
            let durationText = '';
            if (callData.duration && callData.duration > 0) {
                const minutes = Math.floor(callData.duration / 60);
                const seconds = callData.duration % 60;
                durationText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Get relationship insights
            let relationshipInsight = '';
            if (otherParticipantIds.length === 1) {
                const insights = getRelationshipInsights(otherParticipantIds[0]);
                if (insights.lastCall !== null && insights.lastCall > 0) {
                    relationshipInsight = `Last call: ${insights.lastCall}d ago`;
                } else if (insights.totalCalls > 1) {
                    relationshipInsight = `Called ${insights.totalCalls} times`;
                }
            }
            
            const callItem = document.createElement('div');
            callItem.className = 'call-item';
            callItem.dataset.callId = callData.id || `local_${Date.now()}`;
            
            let statusIconClass = '';
            let statusIcon = '';
            
            if (isMissed) {
                statusIconClass = 'missed';
                statusIcon = isOutgoing ? 'fas fa-phone-slash' : 'fas fa-phone-missed';
            } else if (isOutgoing) {
                statusIconClass = 'outgoing';
                statusIcon = 'fas fa-phone-alt';
            } else {
                statusIconClass = 'incoming';
                statusIcon = 'fas fa-phone';
            }
            
            const initials = displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2);
            
            // Try to get avatar
            let avatarUrl = '';
            if (otherParticipantIds.length === 1) {
                avatarUrl = localStorage.getItem(`userInfo_${otherParticipantIds[0]}_photoURL`) || 
                           localStorage.getItem(`contact_${otherParticipantIds[0]}_avatar`) || 
                           localStorage.getItem(`friend_${otherParticipantIds[0]}_avatar`) || '';
            }
            
            callItem.innerHTML = `
                <div class="call-avatar" ${avatarUrl ? `style="background-image: url('${avatarUrl}')"` : ''}>
                    ${avatarUrl ? '' : `<span>${initials}</span>`}
                    <div class="call-status-icon ${statusIconClass}">
                        <i class="${statusIcon}"></i>
                    </div>
                </div>
                <div class="call-info">
                    <div class="call-name">
                        <span>${displayName}</span>
                        <span class="call-time">${callTime}</span>
                    </div>
                    <div class="call-details">
                        <i class="fas fa-${callType === 'video' ? 'video' : 'phone'}"></i>
                        <span>${isMissed ? 'Missed' : (isOutgoing ? 'Outgoing' : 'Incoming')}</span>
                        ${durationText ? `<span> ${durationText}</span>` : ''}
                        ${callData.isLocal ? '<span class="offline-badge" style="font-size: 10px; padding: 1px 6px;">Local</span>' : ''}
                        ${callData.mood ? `<span class="mood-indicator mood-${callData.mood}" style="font-size: 10px; padding: 1px 6px;"><i class="fas fa-smile"></i> ${callData.mood.charAt(0).toUpperCase() + callData.mood.slice(1)}</span>` : ''}
                    </div>
                    ${relationshipInsight ? `<div class="relationship-memory ${insights.frequency === 'Frequent contact' ? 'frequent-contact' : insights.frequency === 'Regular contact' ? 'recent-contact' : 'occasional-contact'}"><i class="fas fa-history"></i> ${relationshipInsight}</div>` : ''}
                </div>
                <button class="call-action-btn" title="Call Back" ${!isOnline ? 'disabled' : ''}>
                    <i class="fas fa-phone"></i>
                </button>
            `;
            
            const callbackBtn = callItem.querySelector('.call-action-btn');
            callbackBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    return;
                }
                
                if (otherParticipantIds.length > 0) {
                    if (isGroupCall) {
                        startGroupCall(otherParticipantIds);
                    } else if (otherParticipantIds.length === 1) {
                        startCall(otherParticipantIds[0], callType);
                    }
                } else {
                    showNotification('Cannot call: No participant information', 'info');
                }
            });
            
            container.appendChild(callItem);
        }
        
        function listenForExternalCalls() {
            // Listen for messages from other tabs (like friends.html)
            window.addEventListener('message', function(event) {
                console.log('Message received from friends.html:', event.data);
                
                // Check if offline before processing call requests
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    return;
                }
                
                // Accept calls initiated from friends.html
                if (event.data && event.data.type === 'callUser') {
                    const userId = event.data.userId;
                    const callType = event.data.callType || 'video';
                    
                    console.log('Call request from friends.html:', userId, callType);
                    startCallFromFriend(userId, callType);
                }
                
                // Handle video call requests specifically
                if (event.data && event.data.type === 'videoCall') {
                    const userId = event.data.userId;
                    console.log('Video call request from friends.html:', userId);
                    startCallFromFriend(userId, 'video');
                }
                
                // Handle voice call requests specifically
                if (event.data && event.data.type === 'voiceCall') {
                    const userId = event.data.userId;
                    console.log('Voice call request from friends.html:', userId);
                    startCallFromFriend(userId, 'voice');
                }
                
                // Handle open calls page
                if (event.data && event.data.type === 'openCallsPage') {
                    console.log('Opening calls page from friends.html');
                    // Ensure calls page is properly loaded
                    if (window.location.pathname.includes('calls.html')) {
                        // Already on calls page, refresh call history
                        if (isOnline) {
                            startBackgroundSync();
                        } else {
                            loadCallsFromCache();
                        }
                    }
                }
                
                // Handle settings updates
                if (event.data && event.data.type === 'settingsUpdated') {
                    console.log('Settings updated from friends.html');
                    // Reload settings
                    SettingsManager.initializeSettings();
                }
                
                // Handle navigation context
                if (event.data && event.data.type === 'navigationContext') {
                    lastNavigationContext = event.data.context;
                    localStorage.setItem('lastNavigationContext', JSON.stringify(event.data.context));
                }
            });
            
            // Also listen for localStorage changes (alternative communication method)
            window.addEventListener('storage', function(event) {
                if (event.key === 'callRequest' && event.newValue) {
                    try {
                        const callRequest = JSON.parse(event.newValue);
                        if (callRequest.userId && callRequest.initiator !== currentUser.uid) {
                            console.log('Call request via localStorage:', callRequest);
                            
                            if (callRequest.type === 'videoCall' || callRequest.type === 'voiceCall') {
                                const callType = callRequest.type === 'videoCall' ? 'video' : 'voice';
                                startCallFromFriend(callRequest.userId, callType);
                                
                                // Clear the request
                                localStorage.removeItem('callRequest');
                            }
                        }
                    } catch (error) {
                        console.error('Error parsing call request from localStorage:', error);
                    }
                }
            });
        }
        
        async function initializeUser() {
            // Get user info from app.js context or local storage
            const userInfo = localStorage.getItem(`userInfo_${currentUser.uid}`);
            if (userInfo) {
                const userData = JSON.parse(userInfo);
                window.userInitials = userData.displayName 
                    ? userData.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2)
                    : 'ME';
                window.userAvatar = userData.photoURL || '';
            } else if (currentUser) {
                window.userInitials = currentUser.displayName 
                    ? currentUser.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2)
                    : 'ME';
                window.userAvatar = currentUser.photoURL || '';
            }
        }
        
        async function loadUserSubscription() {
            try {
                // Try to load from localStorage first (works offline)
                const localSubscription = localStorage.getItem(`subscription_${currentUser.uid}`);
                if (localSubscription) {
                    userSubscription = JSON.parse(localSubscription);
                    
                    // Check if trial has expired
                    if (userSubscription.trialStartDate) {
                        const trialStart = new Date(userSubscription.trialStartDate);
                        const now = new Date();
                        const daysSinceTrialStart = Math.floor((now - trialStart) / (1000 * 60 * 60 * 24));
                        userSubscription.trialDaysLeft = Math.max(0, 30 - daysSinceTrialStart);
                        
                        // If trial has expired, reset to free tier
                        if (userSubscription.trialDaysLeft === 0 && userSubscription.subscriptionType === 'free') {
                            userSubscription.maxGroupParticipants = 8;
                            userSubscription.isPremium = false;
                        }
                    }
                }
                
                // Only try backend if online
                if (isOnline && window.api && typeof window.api.get === 'function') {
                    try {
                        const response = await window.api.get(`/api/users/${currentUser.uid}/subscription`);
                        if (response && response.data) {
                            const subscriptionData = response.data;
                            userSubscription = {
                                isPremium: subscriptionData.isPremium || false,
                                trialDaysLeft: subscriptionData.trialDaysLeft || 30,
                                maxGroupParticipants: subscriptionData.maxGroupParticipants || 8,
                                subscriptionType: subscriptionData.subscriptionType || 'free',
                                trialStartDate: subscriptionData.trialStartDate || new Date().toISOString(),
                                paymentHistory: subscriptionData.paymentHistory || []
                            };
                            
                            // Save to localStorage for offline use
                            localStorage.setItem(`subscription_${currentUser.uid}`, JSON.stringify(userSubscription));
                        }
                    } catch (error) {
                        console.error('Error loading subscription from backend:', error);
                    }
                }
                
                console.log('User subscription loaded:', userSubscription);
                
                // Update UI based on subscription
                updateSubscriptionUI();
                
            } catch (error) {
                console.error('Error loading user subscription:', error);
                // Use default subscription if loading fails
                userSubscription = {
                    isPremium: false,
                    trialDaysLeft: 30,
                    maxGroupParticipants: 8,
                    subscriptionType: 'free',
                    trialStartDate: new Date().toISOString(),
                    paymentHistory: []
                };
                updateSubscriptionUI();
            }
        }
        
        function updateSubscriptionUI() {
            // Update group call button with trial info
            const groupCallBtn = document.getElementById('groupCallBtn');
            if (groupCallBtn) {
                if (userSubscription.trialDaysLeft > 0) {
                    const premiumBadge = groupCallBtn.querySelector('.premium-badge-small');
                    if (premiumBadge) {
                        premiumBadge.textContent = `${userSubscription.trialDaysLeft}d Free`;
                        premiumBadge.style.background = 'var(--premium-gradient)';
                    }
                } else if (userSubscription.isPremium) {
                    const premiumBadge = groupCallBtn.querySelector('.premium-badge-small');
                    if (premiumBadge) {
                        premiumBadge.textContent = 'Premium';
                        premiumBadge.style.background = 'var(--premium-gradient)';
                    }
                } else {
                    const premiumBadge = groupCallBtn.querySelector('.premium-badge-small');
                    if (premiumBadge) {
                        premiumBadge.textContent = '8 Max';
                        premiumBadge.style.background = 'var(--secondary-color)';
                        premiumBadge.style.color = 'var(--text-secondary)';
                    }
                }
            }
            
            // Update premium badges on features
            const premiumBadges = document.querySelectorAll('.premium-badge-small');
            premiumBadges.forEach(badge => {
                if (badge.textContent === 'Free') {
                    if (userSubscription.trialDaysLeft > 0) {
                        badge.textContent = `${userSubscription.trialDaysLeft}d Free`;
                        badge.style.background = 'var(--premium-gradient)';
                    } else if (userSubscription.isPremium) {
                        badge.textContent = 'Premium';
                        badge.style.background = 'var(--premium-gradient)';
                    } else {
                        badge.textContent = 'Premium';
                        badge.style.background = 'var(--secondary-color)';
                        badge.style.color = 'var(--text-secondary)';
                    }
                }
            });
        }
        
        async function checkGroupCallEligibility(participantCount) {
            const totalParticipants = participantCount + 1; // +1 for current user
            
            // Free tier allows up to 8 participants
            if (totalParticipants <= userSubscription.maxGroupParticipants) {
                return { eligible: true, reason: '' };
            }
            
            // Check if user is in trial period
            if (userSubscription.trialDaysLeft > 0) {
                // During trial, allow unlimited participants
                return { eligible: true, reason: 'trial' };
            }
            
            // Check if user is premium
            if (userSubscription.isPremium) {
                return { eligible: true, reason: 'premium' };
            }
            
            // User needs to upgrade
            return { 
                eligible: false, 
                reason: 'upgrade_required',
                currentLimit: userSubscription.maxGroupParticipants,
                requiredLimit: totalParticipants
            };
        }
        
        async function processPremiumPayment(phoneNumber, amount) {
            if (!isOnline) {
                throw new Error('Payment requires connection');
            }
            
            try {
                showNotification('Processing payment...', 'success');
                
                // ==================== BACKEND MIGRATION: Use API for payment ====================
                if (window.api && typeof window.api.post === 'function') {
                    const response = await window.api.post('/api/payments/mpesa', {
                        phoneNumber: phoneNumber,
                        amount: amount,
                        userId: currentUser.uid,
                        service: 'premium_upgrade'
                    });
                    
                    if (response && response.success) {
                        // Update user subscription
                        userSubscription.isPremium = true;
                        userSubscription.subscriptionType = 'premium_monthly';
                        userSubscription.maxGroupParticipants = 50; // Premium allows up to 50 participants
                        userSubscription.paymentHistory.push({
                            transactionId: response.transactionId,
                            amount: amount,
                            phoneNumber: phoneNumber,
                            date: new Date().toISOString(),
                            status: 'completed'
                        });
                        
                        // Save to localStorage
                        localStorage.setItem(`subscription_${currentUser.uid}`, JSON.stringify(userSubscription));
                        
                        // Update UI
                        updateSubscriptionUI();
                        
                        return {
                            success: true,
                            transactionId: response.transactionId,
                            message: 'Payment successful! Your account has been upgraded to Premium.'
                        };
                    } else {
                        throw new Error(response?.message || 'Payment failed');
                    }
                } else {
                    throw new Error('Payment API not available');
                }
                
            } catch (error) {
                console.error('Payment error:', error);
                throw new Error('Payment failed: ' + error.message);
            }
        }
        
        function showPaymentModal(requiredLimit) {
            paymentModal.classList.add('active');
            
            // Update payment amount based on required limit
            const amount = 500; // Base amount for premium
            document.getElementById('paymentAmount').textContent = `KSh ${amount}`;
            document.getElementById('paymentAmountInput').value = amount;
            
            // Store the required limit for when payment is confirmed
            paymentModal.dataset.requiredLimit = requiredLimit;
        }
        
        function setupPresenceTracking() {
            if (!currentUser || !isOnline) return;
            
            // Update presence periodically
            setInterval(() => {
                updateUserPresence(true);
            }, 30000);
        }
        
        function initializePeerJS() {
            if (!currentUser || !isOnline) {
                console.error('Cannot initialize PeerJS: No user logged in or offline');
                return;
            }
            
            try {
                const peerId = `${currentUser.uid}_${Date.now()}`;
                
                console.log('Initializing PeerJS with ID:', peerId);
                
                peer = new Peer(peerId, {
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    secure: true,
                    config: {
                        'iceServers': [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' }
                        ]
                    },
                    debug: 2
                });
                
                peer.on('open', (id) => {
                    console.log(' PeerJS connected successfully with ID:', id);
                    
                    showNotification('Connected to call server', 'success');
                });
                
                peer.on('error', (err) => {
                    console.error(' PeerJS error:', err.type, err.message);
                    
                    let errorMessage = 'Connection error';
                    if (err.type === 'unavailable-id') {
                        errorMessage = 'User ID already in use. Refreshing...';
                        setTimeout(() => location.reload(), 2000);
                    } else if (err.type === 'network') {
                        errorMessage = 'Network error. Check your connection';
                    } else if (err.type === 'peer-unavailable') {
                        errorMessage = 'User is offline or not connected';
                    }
                    
                    showNotification(errorMessage, 'error');
                });
                
                peer.on('connection', (dataConnection) => {
                    console.log('Incoming data connection from:', dataConnection.peer);
                    
                    const userId = dataConnection.peer.split('_')[0];
                    dataConnections.set(userId, dataConnection);
                    
                    dataConnection.on('data', (data) => {
                        handleDataMessage(data, userId);
                    });
                    
                    dataConnection.on('close', () => {
                        console.log('Data connection closed with:', userId);
                        dataConnections.delete(userId);
                    });
                    
                    dataConnection.on('error', (err) => {
                        console.error('Data connection error:', err);
                    });
                });
                
                // Improved incoming call handler for immediate response
                peer.on('call', async (incomingCall) => {
                    console.log(' Incoming call from:', incomingCall.peer);
                    
                    try {
                        const metadata = incomingCall.metadata || {};
                        const callerId = metadata.callerId || incomingCall.peer.split('_')[0];
                        
                        let callerData = null;
                        
                        // Try to get caller info from backend IMMEDIATELY
                        if (isOnline && window.api && typeof window.api.get === 'function') {
                            try {
                                const response = await window.api.get(`/api/users/${callerId}`);
                                if (response && response.data) {
                                    callerData = response.data;
                                }
                            } catch (error) {
                                console.error('Error fetching caller info:', error);
                            }
                        }
                        
                        // If no backend data, check localStorage IMMEDIATELY
                        if (!callerData) {
                            const cachedCaller = localStorage.getItem(`userInfo_${callerId}`);
                            if (cachedCaller) {
                                callerData = JSON.parse(cachedCaller);
                            }
                        }
                        
                        // Fallback to metadata
                        if (!callerData) {
                            callerData = {
                                displayName: metadata.callerName || 'Contact',
                                photoURL: metadata.callerAvatar || ''
                            };
                        }
                        
                        // Update UI IMMEDIATELY
                        document.getElementById('incomingCallName').textContent = callerData.displayName || 'Contact';
                        document.getElementById('incomingCallType').textContent = 
                            metadata.type === 'video' ? 'Incoming Video Call' : 'Incoming Voice Call';
                        
                        // NEW: Update emotional context for incoming call
                        if (window.userSettings && window.userSettings.emotionalContext) {
                            const emotionalContext = document.getElementById('incomingCallEmotionalContext');
                            const moodDisplay = document.getElementById('incomingCallMood');
                            const moodText = document.getElementById('incomingMoodText');
                            const intentionDisplay = document.getElementById('incomingCallIntention');
                            const intentionText = document.getElementById('incomingIntentionText');
                            
                            if (metadata.mood) {
                                emotionalContext.style.display = 'block';
                                moodDisplay.className = 'mood-indicator';
                                moodDisplay.classList.add(`mood-${metadata.mood}`);
                                moodText.textContent = metadata.mood.charAt(0).toUpperCase() + metadata.mood.slice(1);
                            }
                            
                            if (metadata.intention) {
                                emotionalContext.style.display = 'block';
                                intentionDisplay.className = 'intention-indicator';
                                intentionDisplay.classList.add(`intention-${metadata.intention}`);
                                intentionText.textContent = 
                                    metadata.intention === 'checkin' ? 'Just checking in' : 
                                    metadata.intention === 'quick' ? 'Quick chat' :
                                    metadata.intention === 'important' ? 'Important' :
                                    metadata.intention === 'emergency' ? 'Emergency' :
                                    metadata.intention === 'work' ? 'Work-related' : 'Unknown';
                            }
                        }
                        
                        const incomingCallAvatar = document.getElementById('incomingCallAvatar');
                        if (callerData.photoURL) {
                            incomingCallAvatar.style.backgroundImage = `url('${callerData.photoURL}')`;
                            incomingCallAvatar.innerHTML = '';
                        } else {
                            const initials = callerData.displayName ? 
                                callerData.displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                                'C';
                            incomingCallAvatar.innerHTML = `<span style="color: white; font-size: 24px;">${initials}</span>`;
                        }
                        
                        window.incomingCall = incomingCall;
                        window.callerData = {
                            id: callerId,
                            name: callerData.displayName,
                            avatar: callerData.photoURL,
                            peerId: incomingCall.peer,
                            type: metadata.type || 'video',
                            mood: metadata.mood,
                            intention: metadata.intention
                        };
                        
                        // Show modal IMMEDIATELY
                        incomingCallModal.classList.add('active');
                        
                        // Reset button states
                        document.getElementById('declineCallBtn').disabled = false;
                        document.getElementById('acceptCallBtn').disabled = false;
                        document.getElementById('acceptVideoCallBtn').disabled = false;
                        
                        // Auto decline after 45 seconds
                        setTimeout(() => {
                            if (incomingCallModal.classList.contains('active')) {
                                declineCall();
                                showNotification('Missed call from ' + callerData.displayName, 'warning');
                            }
                        }, 45000);
                        
                    } catch (error) {
                        console.error('Error handling incoming call:', error);
                        if (incomingCall) {
                            incomingCall.close();
                        }
                    }
                });
                
                peer.on('disconnected', () => {
                    console.log('PeerJS disconnected, attempting reconnect...');
                    setTimeout(() => {
                        if (peer && peer.disconnected && isOnline) {
                            peer.reconnect();
                        }
                    }, 1000);
                });
                
                peer.on('close', () => {
                    console.log('PeerJS connection closed');
                });
                
            } catch (error) {
                console.error('Error initializing PeerJS:', error);
                showNotification('Failed to initialize call system', 'error');
            }
        }
        
        async function checkUserOnlineStatus(userId) {
            // If we're offline, all users appear offline
            if (!isOnline) {
                return { online: false, lastOnline: 999, peerId: null };
            }
            
            try {
                // ==================== BACKEND MIGRATION: Use API instead of Firebase ====================
                if (window.api && typeof window.api.get === 'function') {
                    const response = await window.api.get(`/api/users/${userId}/presence`);
                    if (response && response.data) {
                        const presenceData = response.data;
                        const lastOnline = presenceData.lastOnline ? new Date(presenceData.lastOnline) : null;
                        const now = new Date();
                        const minutesAgo = lastOnline ? Math.floor((now - lastOnline) / 60000) : 999;
                        
                        return {
                            online: presenceData.online === true,
                            lastOnline: minutesAgo,
                            peerId: presenceData.peerId
                        };
                    }
                }
                return { online: false, lastOnline: 999, peerId: null };
            } catch (error) {
                console.error('Error checking user status:', error);
                return { online: false, lastOnline: 999, peerId: null };
            }
        }
        
        async function startCall(userId, type = 'video') {
            console.log('Starting call to:', userId, 'type:', type);
            
            // Check if offline before starting call
            if (!isOnline) {
                showNotification('Call features require connection', 'info');
                
                // Save as missed call attempt to cache
                await saveCallToLocalStorage({
                    participants: [currentUser.uid, userId],
                    initiator: currentUser.uid,
                    type: type,
                    status: 'missed',
                    timestamp: new Date().toISOString(),
                    missedReason: 'offline_attempt',
                    displayName: await getContactNameWithFallback(userId)
                });
                
                return;
            }
            
            if (!peer || !peer.id || peer.disconnected) {
                showNotification('Not connected to call server. Please wait...', 'error');
                return;
            }
            
            const status = await checkUserOnlineStatus(userId);
            console.log('User status:', status);
            
            if (!status.online) {
                showNotification('Contact is offline. They will see missed call when back online.', 'warning');
                
                // Save missed call to cache
                await saveCallToLocalStorage({
                    participants: [currentUser.uid, userId],
                    initiator: currentUser.uid,
                    type: type,
                    status: 'missed',
                    timestamp: new Date().toISOString(),
                    missedReason: 'user_offline',
                    displayName: await getContactNameWithFallback(userId)
                });
                
                return;
            }
            
            if (!status.peerId) {
                showNotification('Contact is not connected to call server', 'error');
                return;
            }
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: type === 'video',
                    audio: true
                });
                
                let callId = null;
                // ==================== BACKEND MIGRATION: Use API for call invitation ====================
                if (window.api && typeof window.api.post === 'function') {
                    const response = await window.api.post('/api/calls/invite', {
                        from: currentUser.uid,
                        to: userId,
                        type: type,
                        callId: `call_${Date.now()}`,
                        mood: currentMood,
                        intention: currentIntention
                    });
                    
                    if (response && response.data) {
                        callId = response.data.callId;
                    }
                }
                
                currentCallType = type;
                callParticipants = [currentUser.uid, userId];
                
                callContainer.classList.add('active');
                document.getElementById('callTypeIcon').innerHTML = 
                    `<i class="fas fa-${type === 'video' ? 'video' : 'phone'}"></i>`;
                
                // Get actual contact name
                const contactName = await getContactNameWithFallback(userId);
                document.getElementById('callParticipants').textContent = `Calling ${contactName}...`;
                document.getElementById('callStatus').textContent = 'Connecting...';
                
                // Show emotional context if enabled
                if (window.userSettings && window.userSettings.emotionalContext) {
                    const emotionalContextDisplay = document.getElementById('emotionalContextDisplay');
                    emotionalContextDisplay.style.display = 'block';
                }
                
                addVideoStream(currentUser.uid, localStream, true);
                
                currentCall = {
                    callId: callId,
                    targetId: userId,
                    targetPeerId: status.peerId,
                    type: type,
                    startTime: new Date()
                };
                
                initiateWebRTCCall(status.peerId, userId, type, callId);
                
                setTimeout(async () => {
                    if (currentCall && currentCall.status !== 'connected') {
                        console.log('Call timeout - no answer');
                        showNotification('No answer. Call ended.', 'warning');
                        
                        // Save missed call to cache
                        await saveCallToLocalStorage({
                            participants: [currentUser.uid, userId],
                            initiator: currentUser.uid,
                            type: type,
                            status: 'missed',
                            timestamp: new Date().toISOString(),
                            duration: 0,
                            displayName: await getContactNameWithFallback(userId)
                        });
                        
                        endCall();
                    }
                }, 45000);
                
            } catch (error) {
                console.error('Error starting call:', error);
                
                if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    showNotification('Camera or microphone not found', 'error');
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    showNotification('Camera or microphone is already in use', 'error');
                } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                    showNotification('Camera or microphone constraints cannot be satisfied', 'error');
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showNotification('Camera or microphone permission denied', 'error');
                } else if (error.name === 'TypeError' || error.name === 'TypeError') {
                    showNotification('Camera or microphone access not supported', 'error');
                } else {
                    showNotification('Failed to start call: ' + error.message, 'error');
                }
                
                endCall();
            }
        }
        
        async function initiateWebRTCCall(targetPeerId, userId, type, callId) {
            try {
                console.log('Initiating WebRTC call to peer:', targetPeerId);
                
                const call = peer.call(targetPeerId, localStream, {
                    metadata: {
                        callerId: currentUser.uid,
                        callerName: currentUser.displayName || 'User',
                        callerAvatar: currentUser.photoURL || '',
                        type: type,
                        callId: callId,
                        mood: currentMood,
                        intention: currentIntention
                    }
                });
                
                if (!call) {
                    throw new Error('Failed to create call object');
                }
                
                activeCalls.set(userId, call);
                
                call.on('stream', (remoteStream) => {
                    console.log('Received remote stream from:', userId);
                    addVideoStream(userId, remoteStream);
                    
                    if (currentCall) currentCall.status = 'connected';
                    callStartTime = new Date();
                    startCallTimer();
                    
                    // Get actual contact name
                    getContactNameWithFallback(userId).then(contactName => {
                        document.getElementById('callParticipants').textContent = `Connected with ${contactName}`;
                    });
                    document.getElementById('callStatus').textContent = 'In call';
                    
                    // ==================== BACKEND MIGRATION: Use API to delete invitation ====================
                    if (callId && window.api && typeof window.api.delete === 'function') {
                        window.api.delete(`/api/calls/invite/${callId}`);
                    }
                    
                    // Save connected call to cache
                    saveCallToLocalStorage({
                        participants: [currentUser.uid, userId],
                        initiator: currentUser.uid,
                        type: type,
                        status: 'connected',
                        timestamp: new Date().toISOString(),
                        startTime: callStartTime,
                        displayName: getContactNameWithFallback(userId),
                        mood: currentMood,
                        intention: currentIntention
                    });
                    
                    setupDataConnection(userId);
                });
                
                call.on('close', () => {
                    console.log('Call closed with:', userId);
                    removeVideoStream(userId);
                    activeCalls.delete(userId);
                    
                    if (dataConnections.has(userId)) {
                        dataConnections.get(userId).close();
                        dataConnections.delete(userId);
                    }
                    
                    if (activeCalls.size === 0 && currentCall) {
                        endCall();
                    }
                });
                
                call.on('error', (err) => {
                    console.error('Call error with', userId, ':', err);
                    showNotification('Call error: ' + err.message, 'error');
                    removeVideoStream(userId);
                    activeCalls.delete(userId);
                });
                
                if (call.peerConnection) {
                    call.peerConnection.oniceconnectionstatechange = () => {
                        console.log('ICE connection state:', call.peerConnection.iceConnectionState);
                        if (call.peerConnection.iceConnectionState === 'failed' ||
                            call.peerConnection.iceConnectionState === 'disconnected') {
                            showNotification('Network connection unstable', 'warning');
                        }
                    };
                }
                
            } catch (error) {
                console.error('Error initiating WebRTC call:', error);
                showNotification('Failed to connect call: ' + error.message, 'error');
                endCall();
            }
        }
        
        function setupDataConnection(userId) {
            if (dataConnections.has(userId)) return;
            
            try {
                const statusPromise = checkUserOnlineStatus(userId);
                statusPromise.then(status => {
                    if (!status.peerId) return;
                    
                    const dataConnection = peer.connect(status.peerId, {
                        metadata: {
                            userId: currentUser.uid,
                            userName: currentUser.displayName
                        },
                        reliable: true
                    });
                    
                    dataConnection.on('open', () => {
                        console.log('Data connection established with:', userId);
                        dataConnections.set(userId, dataConnection);
                        
                        sendDataMessage(userId, {
                            type: 'handshake',
                            userId: currentUser.uid,
                            userName: currentUser.displayName,
                            timestamp: new Date().toISOString(),
                            mood: currentMood,
                            intention: currentIntention
                        });
                    });
                    
                    dataConnection.on('data', (data) => {
                        handleDataMessage(data, userId);
                    });
                    
                    dataConnection.on('close', () => {
                        console.log('Data connection closed with:', userId);
                        dataConnections.delete(userId);
                    });
                    
                    dataConnection.on('error', (err) => {
                        console.error('Data connection error with', userId, ':', err);
                    });
                    
                }).catch(error => {
                    console.error('Error setting up data connection:', error);
                });
                
            } catch (error) {
                console.error('Error creating data connection:', error);
            }
        }
        
        function sendDataMessage(targetUserId, message) {
            if (dataConnections.has(targetUserId)) {
                const connection = dataConnections.get(targetUserId);
                if (connection.open) {
                    // Ensure emojis are properly encoded
                    if (message.type === 'reaction') {
                        message.reaction = String.fromCodePoint(...message.reaction.split('-').map(c => parseInt(c, 16)));
                    }
                    connection.send(message);
                    return true;
                }
            }
            
            return false;
        }
        
        function broadcastDataMessage(message, excludeUserId = null) {
            dataConnections.forEach((connection, userId) => {
                if (userId !== excludeUserId && connection.open) {
                    // Ensure emojis are properly encoded
                    if (message.type === 'reaction') {
                        message.reaction = String.fromCodePoint(...message.reaction.split('-').map(c => parseInt(c, 16)));
                    }
                    connection.send(message);
                }
            });
        }
        
        function handleDataMessage(data, senderId) {
            console.log('Received data message from:', senderId, data);
            
            switch(data.type) {
                case 'handshake':
                    console.log('Handshake received from:', senderId);
                    // Update participant's emotional context if provided
                    if (data.mood || data.intention) {
                        updateParticipantEmotionalContext(senderId, data.mood, data.intention);
                    }
                    break;
                    
                case 'reaction':
                    if (window.userSettings && window.userSettings.liveReactions) {
                        // Properly display emojis
                        const reaction = data.reaction;
                        showFloatingReaction(reaction);
                    }
                    break;
                    
                case 'chat':
                    if (window.userSettings && window.userSettings.inCallChat) {
                        addChatMessage(data.message, senderId, false);
                    }
                    break;
                    
                case 'whiteboard':
                    if (window.userSettings && window.userSettings.sharedWhiteboard) {
                        handleWhiteboardData(data, senderId);
                    }
                    break;
                    
                case 'call-control':
                    handleCallControlMessage(data, senderId);
                    break;
                    
                // NEW: Handle emotional context messages
                case 'mood':
                    if (window.userSettings && window.userSettings.emotionalContext) {
                        updateParticipantEmotionalContext(senderId, data.mood, null);
                    }
                    break;
                    
                case 'intention':
                    if (window.userSettings && window.userSettings.callIntention) {
                        updateParticipantEmotionalContext(senderId, null, data.intention);
                    }
                    break;
            }
        }
        
        // NEW: Update participant emotional context in UI
        function updateParticipantEmotionalContext(userId, mood, intention) {
            const participantItem = document.querySelector(`.participant-item[data-user-id="${userId}"]`);
            if (participantItem) {
                let emotionalContext = participantItem.querySelector('.participant-emotional-context');
                if (!emotionalContext) {
                    emotionalContext = document.createElement('div');
                    emotionalContext.className = 'participant-emotional-context';
                    emotionalContext.style.fontSize = '11px';
                    emotionalContext.style.marginTop = '3px';
                    emotionalContext.style.display = 'flex';
                    emotionalContext.style.gap = '5px';
                    participantItem.querySelector('.participant-info').appendChild(emotionalContext);
                }
                
                if (mood) {
                    let moodElement = emotionalContext.querySelector('.participant-mood');
                    if (!moodElement) {
                        moodElement = document.createElement('span');
                        moodElement.className = 'mood-indicator';
                        emotionalContext.appendChild(moodElement);
                    }
                    moodElement.className = 'mood-indicator';
                    moodElement.classList.add(`mood-${mood}`);
                    moodElement.innerHTML = `<i class="fas fa-smile"></i> ${mood.charAt(0).toUpperCase() + mood.slice(1)}`;
                }
                
                if (intention) {
                    let intentionElement = emotionalContext.querySelector('.participant-intention');
                    if (!intentionElement) {
                        intentionElement = document.createElement('span');
                        intentionElement.className = 'intention-indicator';
                        emotionalContext.appendChild(intentionElement);
                    }
                    intentionElement.className = 'intention-indicator';
                    intentionElement.classList.add(`intention-${intention}`);
                    intentionElement.innerHTML = `<i class="fas fa-bullseye"></i> ${intention === 'checkin' ? 'Checking in' : intention}`;
                }
            }
        }
        
        function showFloatingReaction(reaction) {
            const reactionElement = document.createElement('div');
            reactionElement.className = 'floating-reaction';
            reactionElement.textContent = reaction;
            reactionElement.style.left = Math.random() * 80 + 10 + '%';
            reactionElement.style.top = Math.random() * 80 + 10 + '%';
            
            callContainer.appendChild(reactionElement);
            
            setTimeout(() => {
                if (reactionElement.parentNode) {
                    reactionElement.remove();
                }
            }, 3000);
        }
        
        async function startGroupCall(userIds) {
            console.log('Starting group call with:', userIds);
            
            // Check if offline
            if (!isOnline) {
                showNotification('Call features require connection', 'info');
                
                // Save group call attempt to cache
                await saveCallToLocalStorage({
                    participants: [currentUser.uid, ...userIds],
                    initiator: currentUser.uid,
                    type: 'video',
                    group: true,
                    status: 'missed',
                    timestamp: new Date().toISOString(),
                    missedReason: 'offline_attempt',
                    displayName: `Group Call (${userIds.length + 1})`
                });
                
                return;
            }
            
            // Check group call eligibility
            const eligibility = await checkGroupCallEligibility(userIds.length);
            
            if (!eligibility.eligible) {
                if (eligibility.reason === 'upgrade_required') {
                    showNotification(`Free tier allows max ${eligibility.currentLimit} participants. Upgrade to Premium for more.`, 'warning');
                    showPaymentModal(eligibility.requiredLimit);
                    return;
                }
                showNotification('Cannot start group call: ' + eligibility.reason, 'error');
                return;
            }
            
            if (!peer || !peer.id || peer.disconnected) {
                showNotification('Not connected to call server', 'error');
                return;
            }
            
            const onlineUsers = [];
            const offlineUsers = [];
            
            for (const userId of userIds) {
                const status = await checkUserOnlineStatus(userId);
                if (status.online && status.peerId) {
                    onlineUsers.push({ id: userId, peerId: status.peerId });
                } else {
                    offlineUsers.push(userId);
                }
            }
            
            if (onlineUsers.length === 0) {
                showNotification('All selected contacts are offline', 'warning');
                return;
            }
            
            if (offlineUsers.length > 0) {
                showNotification(`${offlineUsers.length} contact(s) offline and won't join the call`, 'warning');
            }
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                currentCallType = 'video';
                callParticipants = [currentUser.uid, ...onlineUsers.map(u => u.id)];
                
                callContainer.classList.add('active');
                document.getElementById('callTypeIcon').innerHTML = '<i class="fas fa-users"></i>';
                document.getElementById('callParticipants').textContent = `Group Call (${callParticipants.length})`;
                document.getElementById('callStatus').textContent = 'Starting...';
                
                // Show emotional context if enabled
                if (window.userSettings && window.userSettings.emotionalContext) {
                    const emotionalContextDisplay = document.getElementById('emotionalContextDisplay');
                    emotionalContextDisplay.style.display = 'block';
                }
                
                addVideoStream(currentUser.uid, localStream, true);
                
                currentCall = {
                    group: true,
                    participants: onlineUsers,
                    startTime: new Date(),
                    status: 'connecting'
                };
                
                const callPromises = [];
                for (const user of onlineUsers) {
                    const callId = `group_${Date.now()}_${user.id}`;
                    callPromises.push(initiateWebRTCCall(user.peerId, user.id, 'video', callId));
                }
                
                await Promise.allSettled(callPromises);
                
                callStartTime = new Date();
                startCallTimer();
                if (currentCall) currentCall.status = 'connected';
                
                // Save group call to cache
                await saveCallToLocalStorage({
                    participants: callParticipants,
                    initiator: currentUser.uid,
                    type: 'video',
                    group: true,
                    status: 'connected',
                    timestamp: new Date().toISOString(),
                    startTime: callStartTime,
                    displayName: `Group Call (${callParticipants.length})`,
                    mood: currentMood,
                    intention: currentIntention
                });
                
                updateParticipantsList();
                
                // Show trial/premium message
                if (eligibility.reason === 'trial') {
                    showNotification(`Trial: Group call with ${onlineUsers.length} participant(s). ${userSubscription.trialDaysLeft} days remaining.`, 'success');
                } else if (eligibility.reason === 'premium') {
                    showNotification(`Premium: Group call with ${onlineUsers.length} participant(s)`, 'success');
                } else {
                    showNotification(`Group call started with ${onlineUsers.length} participant(s)`, 'success');
                }
                
            } catch (error) {
                console.error('Error starting group call:', error);
                showNotification('Failed to start group call: ' + error.message, 'error');
                endCall();
            }
        }
        
        function addVideoStream(userId, stream, isLocal = false) {
            const existingVideo = document.querySelector(`[data-user-id="${userId}"]`);
            if (existingVideo) {
                existingVideo.remove();
            }
            
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container fade-in';
            videoContainer.dataset.userId = userId;
            
            if (isLocal) {
                videoContainer.classList.add('pinned');
            }
            
            const video = document.createElement('video');
            video.className = 'video-element';
            video.srcObject = stream;
            video.autoplay = true;
            video.muted = isLocal;
            video.playsInline = true;
            
            let userName = isLocal ? 'You' : 'Contact';
            let userAvatar = '';
            
            if (isLocal) {
                userName = 'You';
                userAvatar = window.userAvatar;
            } else {
                // Try to get user info from backend or localStorage
                const getUserInfo = async () => {
                    try {
                        const contactName = await getContactNameWithFallback(userId);
                        userName = contactName;
                        
                        // Try to get avatar
                        userAvatar = localStorage.getItem(`userInfo_${userId}_photoURL`) || 
                                    localStorage.getItem(`contact_${userId}_avatar`) || 
                                    localStorage.getItem(`friend_${userId}_avatar`) || '';
                    } catch (error) {
                        console.error('Error getting user info:', error);
                    }
                    
                    const nameSpan = videoContainer.querySelector('.video-name span');
                    if (nameSpan) nameSpan.textContent = userName;
                };
                
                getUserInfo();
            }
            
            const videoOverlay = document.createElement('div');
            videoOverlay.className = 'video-overlay';
            videoOverlay.innerHTML = `
                <div class="video-name">
                    <i class="fas fa-${isLocal ? 'user' : 'user-friends'}"></i>
                    <span>${userName}</span>
                </div>
                <div class="video-actions">
                    <button class="video-action-btn" data-action="pin" title="Pin">
                        <i class="fas fa-thumbtack"></i>
                    </button>
                    <button class="video-action-btn" data-action="spotlight" title="Spotlight">
                        <i class="fas fa-star"></i>
                    </button>
                </div>
            `;
            
            videoContainer.appendChild(video);
            videoContainer.appendChild(videoOverlay);
            videoGrid.appendChild(videoContainer);
            
            if (!isLocal) {
                remoteStreams.set(userId, stream);
            }
            
            updateVideoGrid();
            
            videoOverlay.querySelectorAll('.video-action-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    if (action === 'pin') {
                        videoContainer.classList.toggle('pinned');
                        btn.classList.toggle('active');
                    }
                });
            });
        }
        
        function removeVideoStream(userId) {
            const videoElement = document.querySelector(`[data-user-id="${userId}"]`);
            if (videoElement) {
                videoElement.remove();
                remoteStreams.delete(userId);
                updateVideoGrid();
            }
        }
        
        function updateVideoGrid() {
            const videoContainers = document.querySelectorAll('.video-container');
            const count = videoContainers.length;
            
            if (count === 0) return;
            
            videoContainers.forEach(container => {
                container.classList.remove('large');
            });
            
            if (count === 1) {
                videoContainers[0].classList.add('large');
            }
            
            if (currentCall && currentCall.group) {
                document.getElementById('callParticipants').textContent = 
                    `Group Call (${count})`;
            }
        }
        
        function startCallTimer() {
            callStartTime = new Date();
            
            if (callInterval) clearInterval(callInterval);
            
            callInterval = setInterval(() => {
                if (!callStartTime) return;
                
                const now = new Date();
                const diff = Math.floor((now - callStartTime) / 1000);
                const minutes = Math.floor(diff / 60);
                const seconds = diff % 60;
                
                document.getElementById('callDuration').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        async function endCall() {
            console.log('Ending call...');
            
            // Save call continuity data
            saveCallContinuity();
            
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    track.enabled = false;
                });
                localStream = null;
            }
            
            activeCalls.forEach((call, userId) => {
                try {
                    call.close();
                } catch (e) {
                    console.error('Error closing call with', userId, ':', e);
                }
            });
            activeCalls.clear();
            
            dataConnections.forEach((connection, userId) => {
                try {
                    connection.close();
                } catch (e) {
                    console.error('Error closing data connection with', userId, ':', e);
                }
            });
            dataConnections.clear();
            
            remoteStreams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
            });
            remoteStreams.clear();
            
            if (callInterval) {
                clearInterval(callInterval);
                callInterval = null;
            }
            
            if (currentCall && callStartTime) {
                const endTime = new Date();
                const duration = Math.floor((endTime - callStartTime) / 1000);
                
                const participants = currentCall.group ? 
                    callParticipants : 
                    [currentUser.uid, currentCall.targetId];
                
                // Get display name for the call
                let displayName = '';
                if (currentCall.group) {
                    displayName = `Group Call (${participants.length})`;
                } else {
                    displayName = await getContactNameWithFallback(currentCall.targetId);
                }
                
                // Save completed call to cache
                await saveCallToLocalStorage({
                    participants: participants,
                    initiator: currentCall.group ? currentUser.uid : currentCall.initiator,
                    type: currentCallType,
                    status: 'completed',
                    timestamp: new Date().toISOString(),
                    startTime: callStartTime,
                    endTime: endTime,
                    duration: duration,
                    group: currentCall.group || false,
                    displayName: displayName,
                    mood: currentMood,
                    intention: currentIntention
                });
            }
            
            callContainer.classList.remove('active');
            callSidePanel.classList.add('collapsed');
            incomingCallModal.classList.remove('active');
            pipContainer.style.display = 'none';
            
            // Show sidebar again
            document.querySelector('.sidebar').style.display = 'flex';
            
            videoGrid.innerHTML = '';
            
            document.getElementById('callDuration').textContent = '00:00';
            
            // Reset emotional context for next call
            currentMood = 'neutral';
            currentIntention = 'checkin';
            
            // Show private notes modal if this was a meaningful call
            if (currentCall && currentCall.duration > 60) { // More than 1 minute
                setTimeout(() => {
                    showPrivateNotesModal();
                }, 500);
            } else {
                // Show call summary
                setTimeout(() => {
                    showCallSummary();
                }, 500);
            }
            
            currentCall = null;
            callStartTime = null;
            currentCallType = null;
            callParticipants = [];
            
            // Reload call history from cache
            loadCallsFromCache();
            
            // Smart return after call
            setTimeout(() => {
                smartReturnAfterCall();
            }, 1000);
        }
        
        async function acceptCall(type = 'voice') {
            try {
                // Check if offline before accepting call
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    declineCall();
                    return;
                }
                
                const incomingCall = window.incomingCall;
                if (!incomingCall) {
                    showNotification('No incoming call to accept', 'error');
                    return;
                }
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: type === 'video',
                    audio: true
                });
                
                incomingCall.answer(localStream);
                
                currentCall = {
                    targetId: window.callerData.id,
                    type: type,
                    startTime: new Date(),
                    mood: window.callerData.mood,
                    intention: window.callerData.intention
                };
                
                currentCallType = type;
                callParticipants = [currentUser.uid, window.callerData.id];
                
                callContainer.classList.add('active');
                incomingCallModal.classList.remove('active');
                
                document.getElementById('callTypeIcon').innerHTML = 
                    `<i class="fas fa-${type === 'video' ? 'video' : 'phone'}"></i>`;
                document.getElementById('callParticipants').textContent = window.callerData.name;
                document.getElementById('callStatus').textContent = 'Connected';
                
                // Show emotional context if enabled and caller provided it
                if (window.userSettings && window.userSettings.emotionalContext) {
                    const emotionalContextDisplay = document.getElementById('emotionalContextDisplay');
                    emotionalContextDisplay.style.display = 'block';
                    
                    if (window.callerData.mood) {
                        const moodDisplay = document.getElementById('callMoodDisplay');
                        const moodText = document.getElementById('moodText');
                        moodDisplay.className = 'mood-indicator';
                        moodDisplay.classList.add(`mood-${window.callerData.mood}`);
                        moodText.textContent = window.callerData.mood.charAt(0).toUpperCase() + window.callerData.mood.slice(1);
                    }
                    
                    if (window.callerData.intention) {
                        const intentionDisplay = document.getElementById('callIntentionDisplay');
                        const intentionText = document.getElementById('intentionText');
                        intentionDisplay.className = 'intention-indicator';
                        intentionDisplay.classList.add(`intention-${window.callerData.intention}`);
                        intentionDisplay.style.display = 'inline-flex';
                        intentionText.textContent = 
                            window.callerData.intention === 'checkin' ? 'Just checking in' : 
                            window.callerData.intention === 'quick' ? 'Quick chat' :
                            window.callerData.intention === 'important' ? 'Important' :
                            window.callerData.intention === 'emergency' ? 'Emergency' :
                            window.callerData.intention === 'work' ? 'Work-related' : 'Unknown';
                    }
                }
                
                addVideoStream(currentUser.uid, localStream, true);
                
                incomingCall.on('stream', (remoteStream) => {
                    addVideoStream(window.callerData.id, remoteStream);
                    activeCalls.set(window.callerData.id, incomingCall);
                    setupDataConnection(window.callerData.id);
                });
                
                incomingCall.on('close', () => {
                    console.log('Incoming call closed by caller');
                    endCall();
                });
                
                incomingCall.on('error', (err) => {
                    console.error('Incoming call error:', err);
                    showNotification('Call error: ' + err.message, 'error');
                    endCall();
                });
                
                callStartTime = new Date();
                startCallTimer();
                
                // ==================== BACKEND MIGRATION: Use API to delete invitation ====================
                if (incomingCall.metadata && incomingCall.metadata.callId && window.api && typeof window.api.delete === 'function') {
                    await window.api.delete(`/api/calls/invite/${incomingCall.metadata.callId}`);
                }
                
                // Save accepted call to cache
                await saveCallToLocalStorage({
                    participants: [currentUser.uid, window.callerData.id],
                    initiator: window.callerData.id,
                    type: type,
                    status: 'completed',
                    timestamp: new Date().toISOString(),
                    startTime: callStartTime,
                    displayName: window.callerData.name,
                    mood: window.callerData.mood,
                    intention: window.callerData.intention
                });
                
                window.incomingCall = null;
                window.callerData = null;
                
            } catch (error) {
                console.error('Error accepting call:', error);
                showNotification('Failed to accept call: ' + error.message, 'error');
                declineCall();
            }
        }
        
        async function declineCall() {
            console.log('Declining call...');
            
            if (window.incomingCall) {
                try {
                    window.incomingCall.close();
                } catch (e) {
                    console.error('Error closing incoming call:', e);
                }
                
                if (window.callerData) {
                    // Save missed call to cache
                    await saveCallToLocalStorage({
                        participants: [currentUser.uid, window.callerData.id],
                        initiator: window.callerData.id,
                        type: window.callerData.type,
                        status: 'missed',
                        timestamp: new Date().toISOString(),
                        displayName: window.callerData.name,
                        mood: window.callerData.mood,
                        intention: window.callerData.intention
                    });
                }
                
                window.incomingCall = null;
                window.callerData = null;
            }
            
            incomingCallModal.classList.remove('active');
            showNotification('Call declined', 'success');
        }
        
        async function loadAllCalls() {
            try {
                // Show cached data immediately
                await loadCallsFromCache();
                
                // Then try to sync from server in background
                if (isOnline) {
                    startBackgroundSync();
                }
                
            } catch (error) {
                console.error('Error loading all calls:', error);
                showNotification('Failed to load call history', 'error');
            }
        }
        
        function formatTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return `${Math.floor(diffDays / 7)}w ago`;
        }
        
        function initializeWhiteboard() {
            whiteboardCanvas = document.getElementById('whiteboardCanvas');
            if (!whiteboardCanvas) return;
            
            whiteboardCtx = whiteboardCanvas.getContext('2d');
            whiteboardCanvas.width = whiteboardCanvas.offsetWidth;
            whiteboardCanvas.height = whiteboardCanvas.offsetHeight;
            
            whiteboardCtx.strokeStyle = '#000000';
            whiteboardCtx.lineWidth = 2;
            whiteboardCtx.lineCap = 'round';
            
            whiteboardCtx.fillStyle = '#ffffff';
            whiteboardCtx.fillRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            
            whiteboardCanvas.addEventListener('mousedown', startDrawing);
            whiteboardCanvas.addEventListener('mousemove', draw);
            whiteboardCanvas.addEventListener('mouseup', stopDrawing);
            whiteboardCanvas.addEventListener('mouseout', stopDrawing);
            
            whiteboardCanvas.addEventListener('touchstart', handleTouchStart);
            whiteboardCanvas.addEventListener('touchmove', handleTouchMove);
            whiteboardCanvas.addEventListener('touchend', stopDrawing);
        }
        
        function startDrawing(e) {
            if (!window.userSettings || !window.userSettings.sharedWhiteboard) return;
            
            isDrawing = true;
            const rect = whiteboardCanvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            
            if (currentTool === 'pencil') {
                whiteboardCtx.beginPath();
                whiteboardCtx.moveTo(lastX, lastY);
            }
        }
        
        function draw(e) {
            if (!isDrawing || !window.userSettings || !window.userSettings.sharedWhiteboard) return;
            
            const rect = whiteboardCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            switch(currentTool) {
                case 'pencil':
                    whiteboardCtx.lineTo(x, y);
                    whiteboardCtx.stroke();
                    break;
            }
            
            lastX = x;
            lastY = y;
        }
        
        function stopDrawing() {
            isDrawing = false;
            if (currentTool === 'pencil') {
                whiteboardCtx.closePath();
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            whiteboardCanvas.dispatchEvent(mouseEvent);
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            whiteboardCanvas.dispatchEvent(mouseEvent);
        }
        
        function clearWhiteboard() {
            if (!window.userSettings || !window.userSettings.sharedWhiteboard) return;
            whiteboardCtx.fillStyle = '#ffffff';
            whiteboardCtx.fillRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
        }
        
        async function shareScreen() {
            try {
                if (isScreenSharing) {
                    // Stop screen sharing
                    if (localStream) {
                        localStream.getVideoTracks()[0].stop();
                    }
                    
                    // Get camera stream
                    const cameraStream = await navigator.mediaDevices.getUserMedia({ 
                        video: true,
                        audio: false
                    });
                    
                    if (localStream) {
                        const videoTrack = cameraStream.getVideoTracks()[0];
                        const oldVideoTrack = localStream.getVideoTracks()[0];
                        
                        localStream.removeTrack(oldVideoTrack);
                        localStream.addTrack(videoTrack);
                        
                        // Update all active calls
                        activeCalls.forEach(call => {
                            if (call.peerConnection) {
                                const senders = call.peerConnection.getSenders();
                                senders.forEach(sender => {
                                    if (sender.track && sender.track.kind === 'video') {
                                        sender.replaceTrack(videoTrack);
                                    }
                                });
                            }
                        });
                    }
                    
                    isScreenSharing = false;
                    document.getElementById('screenShareBtn').classList.remove('active');
                    
                    showNotification('Stopped screen sharing', 'success');
                    
                } else {
                    // Start screen sharing
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            displaySurface: 'monitor',
                            cursor: 'always'
                        },
                        audio: false
                    });
                    
                    if (!localStream) {
                        showNotification('No local stream available', 'error');
                        return;
                    }
                    
                    const screenTrack = screenStream.getVideoTracks()[0];
                    const oldVideoTrack = localStream.getVideoTracks()[0];
                    
                    localStream.removeTrack(oldVideoTrack);
                    localStream.addTrack(screenTrack);
                    
                    // Update all active calls
                    activeCalls.forEach(call => {
                        if (call.peerConnection) {
                            const senders = call.peerConnection.getSenders();
                                senders.forEach(sender => {
                                    if (sender.track && sender.track.kind === 'video') {
                                        sender.replaceTrack(screenTrack);
                                    }
                                });
                        }
                    });
                    
                    isScreenSharing = true;
                    document.getElementById('screenShareBtn').classList.add('active');
                    
                    showNotification('Screen sharing started', 'success');
                    
                    // Handle when user stops sharing
                    screenTrack.onended = () => {
                        shareScreen();
                    };
                }
                
            } catch (error) {
                console.error('Error sharing screen:', error);
                if (error.name === 'NotAllowedError') {
                    showNotification('Screen sharing permission denied', 'error');
                } else {
                    showNotification('Failed to share screen: ' + error.message, 'error');
                }
            }
        }
        
        function updateParticipantsList() {
            const participantsList = document.getElementById('participantsList');
            if (!participantsList) return;
            
            participantsList.innerHTML = '';
            
            addParticipantItem(currentUser.uid, 'You', window.userAvatar, true, true);
            
            remoteStreams.forEach((stream, userId) => {
                // Try to get user info
                const getUserInfo = async () => {
                    try {
                        const contactName = await getContactNameWithFallback(userId);
                        const contactAvatar = localStorage.getItem(`userInfo_${userId}_photoURL`) || 
                                            localStorage.getItem(`contact_${userId}_avatar`) || 
                                            localStorage.getItem(`friend_${userId}_avatar`) || '';
                        
                        addParticipantItem(userId, contactName, contactAvatar, false, true);
                    } catch (error) {
                        console.error('Error getting participant info:', error);
                        addParticipantItem(userId, 'Contact', '', false, true);
                    }
                };
                
                getUserInfo();
            });
        }
        
        function addParticipantItem(userId, name, avatar, isLocal, isOnline) {
            const participantsList = document.getElementById('participantsList');
            if (!participantsList) return;
            
            const participantItem = document.createElement('div');
            participantItem.className = 'participant-item';
            participantItem.dataset.userId = userId;
            
            const initials = name.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2);
            
            participantItem.innerHTML = `
                <div class="participant-avatar" ${avatar ? `style="background-image: url('${avatar}')"` : ''}>
                    ${avatar ? '' : `<span>${initials}</span>`}
                </div>
                <div class="participant-info">
                    <div class="participant-name">${name}</div>
                    <div class="participant-status ${isOnline ? 'active' : 'offline'}">
                        <i class="fas fa-circle"></i>
                        ${isLocal ? 'You' : (isOnline ? 'Connected' : 'Offline')}
                    </div>
                </div>
                ${!isLocal ? `
                <div class="participant-actions">
                    <button class="video-action-btn" data-action="pin-user" title="Pin">
                        <i class="fas fa-thumbtack"></i>
                    </button>
                </div>
                ` : ''}
            `;
            
            participantsList.appendChild(participantItem);
        }
        
        async function loadContacts() {
            const contactsList = document.getElementById('contactsList');
            const groupContactsList = document.getElementById('groupContactsList');
            
            // If offline, show offline message
            if (!isOnline) {
                const offlineMessage = '<div class="offline-contacts-message"><i class="fas fa-wifi-slash"></i><p>Contacts unavailable while offline</p><p class="subtext">Call features require connection</p></div>';
                contactsList.innerHTML = offlineMessage;
                groupContactsList.innerHTML = offlineMessage;
                return;
            }
            
            contactsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading contacts...</div>';
            groupContactsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading contacts...</div>';
            
            try {
                if (!window.api || typeof window.api.get !== 'function') {
                    throw new Error('API not available');
                }
                
                // ==================== BACKEND MIGRATION: Use API for contacts ====================
                const response = await window.api.get('/api/users/contacts', {
                    params: {
                        userId: currentUser.uid,
                        limit: 50,
                        excludeSelf: true
                    }
                });
                
                contactsList.innerHTML = '';
                groupContactsList.innerHTML = '';
                
                if (!response || !response.data || response.data.length === 0) {
                    const emptyMessage = '<div class="offline-contacts-message"><i class="fas fa-users"></i><p>No contacts found</p></div>';
                    contactsList.innerHTML = emptyMessage;
                    groupContactsList.innerHTML = emptyMessage;
                    return;
                }
                
                for (const userData of response.data) {
                    const status = await checkUserOnlineStatus(userData.uid);
                    userData.online = status.online;
                    userData.lastOnline = status.lastOnline;
                    
                    addContactItem(userData, contactsList);
                    addContactItem(userData, groupContactsList);
                }
                
            } catch (error) {
                console.error('Error loading contacts:', error);
                showNotification('Failed to load contacts', 'error');
                
                // Show offline message
                const offlineMessage = '<div class="offline-contacts-message"><i class="fas fa-wifi-slash"></i><p>Contacts unavailable while offline</p><p class="subtext">Call features require connection</p></div>';
                contactsList.innerHTML = offlineMessage;
                groupContactsList.innerHTML = offlineMessage;
            }
        }
        
        function addContactItem(userData, container) {
            const contactItem = document.createElement('div');
            contactItem.className = 'contact-item';
            contactItem.dataset.userId = userData.uid;
            
            const initials = userData.displayName ? 
                userData.displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                'C';
            
            let statusText = userData.online ? 'Online now' : 
                userData.lastOnline < 5 ? 'Just now' :
                userData.lastOnline < 60 ? `${userData.lastOnline}m ago` :
                `${Math.floor(userData.lastOnline / 60)}h ago`;
            
            // Get relationship insights
            const insights = getRelationshipInsights(userData.uid);
            let relationshipText = '';
            if (insights.totalCalls > 0) {
                if (insights.frequency === 'Frequent contact') {
                    relationshipText = 'Frequent contact';
                } else if (insights.lastCall !== null && insights.lastCall < 7) {
                    relationshipText = `Last call: ${insights.lastCall}d ago`;
                }
            }
            
            contactItem.innerHTML = `
                <input type="checkbox" class="contact-checkbox" id="contact_${userData.uid}" ${!isOnline ? 'disabled' : ''}>
                <div class="call-avatar" ${userData.photoURL ? `style="background-image: url('${userData.photoURL}')"` : ''}>
                    ${userData.photoURL ? '' : `<span>${initials}</span>`}
                    <div class="call-status-icon ${userData.online ? 'incoming' : 'missed'}" style="width: 12px; height: 12px;">
                        <i class="fas fa-circle" style="font-size: 6px;"></i>
                    </div>
                </div>
                <div class="call-info" style="flex: 1;">
                    <div class="call-name">
                        <span>${userData.displayName || 'Contact'}</span>
                    </div>
                    <div class="call-details">
                        <span style="color: ${userData.online ? 'var(--success-color)' : 'var(--text-secondary)'}">
                            ${statusText}
                        </span>
                        ${relationshipText ? `<span class="relationship-memory frequent-contact" style="font-size: 10px;"><i class="fas fa-history"></i> ${relationshipText}</span>` : ''}
                    </div>
                </div>
            `;
            
            const checkbox = contactItem.querySelector('.contact-checkbox');
            checkbox.addEventListener('change', function() {
                if (!isOnline) {
                    showNotification('Cannot select contacts while offline', 'info');
                    this.checked = false;
                    return;
                }
                
                if (this.checked) {
                    selectedContacts.push(userData.uid);
                    contactItem.classList.add('selected');
                } else {
                    selectedContacts = selectedContacts.filter(id => id !== userData.uid);
                    contactItem.classList.remove('selected');
                }
            });
            
            container.appendChild(contactItem);
        }
        
        function addChatMessage(message, senderId, isSent = false) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isSent ? 'sent' : 'received'}`;
            
            let senderName = 'Contact';
            if (senderId === currentUser.uid) {
                senderName = 'You';
            } else {
                // Try to get sender name
                getContactNameWithFallback(senderId).then(contactName => {
                    senderName = contactName;
                    const senderDiv = messageDiv.querySelector('.message-sender');
                    if (senderDiv) senderDiv.textContent = senderName;
                });
            }
            
            messageDiv.innerHTML = `
                <div class="message-sender">${senderName}</div>
                <div class="message-content">${message}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function showNotification(message, type = 'success') {
            const notificationText = document.getElementById('notificationText');
            if (!notificationText) return;
            
            notificationText.textContent = message;
            
            notification.className = 'notification';
            notification.classList.add(type);
            
            notification.classList.add('active');
            
            setTimeout(() => {
                notification.classList.remove('active');
            }, 3000);
        }
        
        function handleCallControlMessage(data, senderId) {
            switch(data.action) {
                case 'mute-status':
                    console.log(`User ${senderId} mute status: ${data.muted}`);
                    break;
                case 'video-status':
                    console.log(`User ${senderId} video status: ${data.videoOff}`);
                    break;
            }
        }
        
        function handleWhiteboardData(data, senderId) {
            // Implement whiteboard data synchronization here
            console.log('Whiteboard data received:', data, 'from:', senderId);
        }
        
        // ==================== COMPLETE EVENT LISTENERS SETUP ====================
        function setupEventListeners() {
            // Store original button titles
            const callButtons = [
                'newCallBtn',
                'voiceCallBtn',
                'videoCallBtn',
                'groupCallBtn',
                'startCallBtn',
                'createVoiceLinkBtn',
                'createVideoLinkBtn',
                'addParticipantsBtn'
            ];
            
            callButtons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button && button.title) {
                    button.setAttribute('data-original-title', button.title);
                }
            });
            
            // Settings toggle
            settingsToggle.addEventListener('click', function() {
                if (!settingsPanel) return;
                
                settingsPanel.classList.toggle('active');
                const icon = this.querySelector('i.fa-chevron-down');
                if (icon) {
                    icon.classList.toggle('fa-chevron-down');
                    icon.classList.toggle('fa-chevron-up');
                }
            });
            
            // Settings toggles - connected to SettingsManager
            document.querySelectorAll('input[data-setting]').forEach(input => {
                input.addEventListener('change', function() {
                    const settingName = this.dataset.setting;
                    const value = this.type === 'checkbox' ? this.checked : this.value;
                    SettingsManager.saveSetting(settingName, value);
                });
            });
            
            // Reset call settings button
            const resetSettingsBtn = document.getElementById('resetSettingsBtn');
            if (resetSettingsBtn) {
                resetSettingsBtn.addEventListener('click', () => {
                    SettingsManager.resetCallSettings();
                });
            }
            
            // NEW: Focus mode button
            if (focusModeBtn) {
                focusModeBtn.addEventListener('click', toggleFocusMode);
            }
            
            // NEW: Mood button
            if (moodBtn) {
                moodBtn.addEventListener('click', showMoodSelection);
            }
            
            // NEW: Intention button
            if (intentionBtn) {
                intentionBtn.addEventListener('click', showIntentionSelection);
            }
            
            // Mood selection modal
            document.querySelectorAll('.mood-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.mood-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                });
            });
            
            document.getElementById('cancelMoodBtn').addEventListener('click', () => {
                moodSelectionModal.classList.remove('active');
            });
            
            document.getElementById('confirmMoodBtn').addEventListener('click', () => {
                const selectedMood = document.querySelector('.mood-option.selected');
                if (selectedMood) {
                    setMood(selectedMood.dataset.mood);
                }
            });
            
            // Intention selection modal
            document.querySelectorAll('.intention-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.intention-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                });
            });
            
            document.getElementById('cancelIntentionBtn').addEventListener('click', () => {
                intentionSelectionModal.classList.remove('active');
            });
            
            document.getElementById('confirmIntentionBtn').addEventListener('click', () => {
                const selectedIntention = document.querySelector('.intention-option.selected');
                if (selectedIntention) {
                    setIntention(selectedIntention.dataset.intention);
                }
            });
            
            // Private notes modal
            document.getElementById('skipNotesBtn').addEventListener('click', () => {
                privateNotesModal.classList.remove('active');
                // Show call summary after skipping notes
                setTimeout(() => {
                    showCallSummary();
                }, 300);
            });
            
            document.getElementById('savePrivateNotesBtn').addEventListener('click', async () => {
                await savePrivateNotes();
                // Show call summary after saving notes
                setTimeout(() => {
                    showCallSummary();
                }, 300);
            });
            
            // Call summary modal
            document.getElementById('closeSummaryBtn').addEventListener('click', () => {
                callSummaryModal.classList.remove('active');
            });
            
            // New call button
            document.getElementById('newCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    return;
                }
                
                newCallModal.classList.add('active');
                loadContacts();
                selectedContacts = [];
            });
            
            // Quick action buttons
            document.getElementById('voiceCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="contacts"]').click();
            });
            
            document.getElementById('videoCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="contacts"]').click();
            });
            
            document.getElementById('groupCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="group"]').click();
            });
            
            // Close new call modal
            document.getElementById('closeNewCallModal').addEventListener('click', () => {
                newCallModal.classList.remove('active');
                selectedContacts = [];
            });
            
            document.getElementById('cancelNewCallBtn').addEventListener('click', () => {
                newCallModal.classList.remove('active');
                selectedContacts = [];
            });
            
            // New call tabs
            document.querySelectorAll('.new-call-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.dataset.tab;
                    
                    document.querySelectorAll('.new-call-tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    document.querySelectorAll('.new-call-tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    const tabContent = document.getElementById(`${tabName}Tab`);
                    if (tabContent) {
                        tabContent.classList.add('active');
                    }
                });
            });
            
            // Start call button
            document.getElementById('startCallBtn').addEventListener('click', async () => {
                if (!isOnline) {
                    showNotification('Call features require connection', 'info');
                    return;
                }
                
                const activeTab = document.querySelector('.new-call-tab.active');
                if (!activeTab) return;
                
                const activeTabName = activeTab.dataset.tab;
                
                if (activeTabName === 'contacts') {
                    if (selectedContacts.length === 0) {
                        showNotification('Please select at least one contact', 'info');
                        return;
                    }
                    
                    if (selectedContacts.length === 1) {
                        startCall(selectedContacts[0], 'video');
                    } else {
                        startGroupCall(selectedContacts);
                    }
                    
                } else if (activeTabName === 'group') {
                    if (selectedContacts.length === 0) {
                        showNotification('Please select participants', 'info');
                        return;
                    }
                    
                    startGroupCall(selectedContacts);
                    
                } else if (activeTabName === 'link') {
                    showNotification('Call link feature requires backend setup', 'warning');
                }
                
                newCallModal.classList.remove('active');
                selectedContacts = [];
            });
            
            // Incoming call buttons
            document.getElementById('declineCallBtn').addEventListener('click', function() {
                this.disabled = true;
                declineCall();
            });
            
            document.getElementById('acceptCallBtn').addEventListener('click', function() {
                this.disabled = true;
                acceptCall('voice');
            });
            
            document.getElementById('acceptVideoCallBtn').addEventListener('click', function() {
                this.disabled = true;
                acceptCall('video');
            });
            
            // Call control buttons
            document.getElementById('muteBtn').addEventListener('click', function() {
                if (localStream) {
                    const audioTrack = localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        isMuted = !audioTrack.enabled;
                        
                        this.classList.toggle('active', isMuted);
                        const icon = this.querySelector('i');
                        if (isMuted) {
                            icon.className = 'fas fa-microphone-slash';
                        } else {
                            icon.className = 'fas fa-microphone';
                        }
                        
                        showNotification(isMuted ? 'Microphone muted' : 'Microphone unmuted', 'success');
                        
                        // Only broadcast if online and in a call
                        if (isOnline && currentCall) {
                            broadcastDataMessage({
                                type: 'call-control',
                                action: 'mute-status',
                                muted: isMuted,
                                userId: currentUser.uid
                            });
                        }
                    }
                } else if (!isOnline) {
                    // When offline, just toggle the UI state
                    isMuted = !isMuted;
                    this.classList.toggle('active', isMuted);
                    const icon = this.querySelector('i');
                    if (isMuted) {
                        icon.className = 'fas fa-microphone-slash';
                        showNotification('Microphone would be muted in a real call', 'info');
                    } else {
                        icon.className = 'fas fa-microphone';
                        showNotification('Microphone would be unmuted in a real call', 'info');
                    }
                }
            });
            
            document.getElementById('videoBtn').addEventListener('click', function() {
                if (localStream) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        isVideoOff = !videoTrack.enabled;
                        
                        this.classList.toggle('active', isVideoOff);
                        const icon = this.querySelector('i');
                        if (isVideoOff) {
                            icon.className = 'fas fa-video-slash';
                        } else {
                            icon.className = 'fas fa-video';
                        }
                        
                        showNotification(isVideoOff ? 'Video turned off' : 'Video turned on', 'success');
                        
                        // Only broadcast if online and in a call
                        if (isOnline && currentCall) {
                            broadcastDataMessage({
                                type: 'call-control',
                                action: 'video-status',
                                videoOff: isVideoOff,
                                userId: currentUser.uid
                            });
                        }
                    }
                } else if (!isOnline) {
                    // When offline, just toggle the UI state
                    isVideoOff = !isVideoOff;
                    this.classList.toggle('active', isVideoOff);
                    const icon = this.querySelector('i');
                    if (isVideoOff) {
                        icon.className = 'fas fa-video-slash';
                        showNotification('Video would be turned off in a real call', 'info');
                    } else {
                        icon.className = 'fas fa-video';
                        showNotification('Video would be turned on in a real call', 'info');
                    }
                }
            });
            
            document.getElementById('speakerBtn').addEventListener('click', function() {
                isSpeakerOn = !isSpeakerOn;
                this.classList.toggle('active', isSpeakerOn);
                
                const icon = this.querySelector('i');
                if (isSpeakerOn) {
                    icon.className = 'fas fa-volume-mute';
                    showNotification('Speaker would be muted in a real call', 'info');
                } else {
                    icon.className = 'fas fa-volume-up';
                    showNotification('Speaker would be unmuted in a real call', 'info');
                }
            });
            
            document.getElementById('screenShareBtn').addEventListener('click', function() {
                if (!isOnline) {
                    showNotification('Screen sharing requires connection', 'info');
                    return;
                }
                
                if (isScreenSharing) {
                    this.classList.remove('active');
                }
                shareScreen();
            });
            
            // More button
            document.getElementById('moreBtn').addEventListener('click', function() {
                callSidePanel.classList.toggle('collapsed');
            });
            
            document.getElementById('endCallBtn').addEventListener('click', function() {
                this.disabled = true;
                endCall();
            });
            
            // Close side panel
            document.getElementById('closePanelBtn').addEventListener('click', () => {
                callSidePanel.classList.add('collapsed');
            });
            
            // Panel tabs
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const panelName = this.dataset.panel;
                    
                    // Check if offline and trying to access features that require internet
                    if (!isOnline && panelName !== 'participants') {
                        showNotification('This feature requires connection', 'info');
                        return;
                    }
                    
                    let isEnabled = true;
                    switch(panelName) {
                        case 'chat':
                            isEnabled = window.userSettings && window.userSettings.inCallChat;
                            break;
                        case 'whiteboard':
                            isEnabled = window.userSettings && window.userSettings.sharedWhiteboard;
                            break;
                        case 'notes':
                            isEnabled = window.userSettings && window.userSettings.sharedNotes;
                            break;
                        case 'polls':
                            isEnabled = window.userSettings && window.userSettings.polls;
                            break;
                        case 'relationship':
                            isEnabled = true; // Always enabled
                            break;
                    }
                    
                    if (!isEnabled) {
                        showNotification('This feature is disabled in your settings', 'warning');
                        return;
                    }
                    
                    document.querySelectorAll('.panel-tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    const panelTitle = document.getElementById('panelTitle');
                    if (panelTitle) {
                        panelTitle.textContent = panelName.charAt(0).toUpperCase() + panelName.slice(1);
                    }
                    
                    document.querySelectorAll('.panel-section').forEach(section => {
                        section.classList.remove('active');
                    });
                    
                    const panelElement = document.getElementById(`${panelName}Panel`);
                    if (panelElement) {
                        panelElement.classList.add('active');
                    }
                    
                    // Load relationship insights if relationship panel
                    if (panelName === 'relationship') {
                        loadRelationshipInsights();
                    }
                });
            });
            
            // Add participants button
            document.getElementById('addParticipantsBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Cannot add participants while offline', 'info');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="contacts"]').click();
            });
            
            // Chat functionality
            document.getElementById('sendChatBtn').addEventListener('click', () => {
                if (!window.userSettings || !window.userSettings.inCallChat) {
                    showNotification('Chat is disabled in your settings', 'warning');
                    return;
                }
                
                if (!isOnline) {
                    showNotification('Chat requires connection', 'info');
                    return;
                }
                
                const chatInput = document.getElementById('chatInput');
                const message = chatInput.value.trim();
                
                if (message) {
                    addChatMessage(message, currentUser.uid, true);
                    
                    broadcastDataMessage({
                        type: 'chat',
                        message: message,
                        senderId: currentUser.uid,
                        senderName: currentUser.displayName || 'User',
                        timestamp: new Date().toISOString()
                    });
                    
                    chatInput.value = '';
                }
            });
            
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('sendChatBtn').click();
                }
            });
            
            // Whiteboard tools
            document.querySelectorAll('[data-tool]').forEach(toolBtn => {
                toolBtn.addEventListener('click', function() {
                    if (!window.userSettings || !window.userSettings.sharedWhiteboard) {
                        showNotification('Whiteboard is disabled in your settings', 'warning');
                        return;
                    }
                    
                    if (!isOnline) {
                        showNotification('Whiteboard requires connection', 'info');
                        return;
                    }
                    
                    currentTool = this.dataset.tool;
                    
                    document.querySelectorAll('[data-tool]').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                });
            });
            
            document.getElementById('clearWhiteboardBtn').addEventListener('click', clearWhiteboard);
            
            // Notes functionality
            document.getElementById('saveNoteBtn').addEventListener('click', () => {
                if (!window.userSettings || !window.userSettings.sharedNotes) {
                    showNotification('Notes are disabled in your settings', 'warning');
                    return;
                }
                
                const note = document.getElementById('notesInput').value;
                localStorage.setItem(`call_note_${Date.now()}`, note);
                showNotification('Note saved locally', 'success');
            });
            
            document.getElementById('loadNotesBtn').addEventListener('click', () => {
                if (!window.userSettings || !window.userSettings.sharedNotes) {
                    showNotification('Notes are disabled in your settings', 'warning');
                    return;
                }
                
                // Load previous notes from localStorage
                const notes = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('call_note_')) {
                        notes.push({
                            key: key,
                            value: localStorage.getItem(key),
                            time: new Date(parseInt(key.split('_')[2]))
                        });
                    }
                }
                
                if (notes.length === 0) {
                    showNotification('No previous notes found', 'warning');
                    return;
                }
                
                // Sort by most recent
                notes.sort((a, b) => b.time - a.time);
                
                // Show the most recent note
                const mostRecentNote = notes[0];
                document.getElementById('notesInput').value = mostRecentNote.value;
                
                // Trigger preview update
                const event = new Event('input');
                document.getElementById('notesInput').dispatchEvent(event);
                
                showNotification('Loaded previous note', 'success');
            });
            
            document.getElementById('notesInput').addEventListener('input', function() {
                const markdown = this.value;
                const html = marked.parse(markdown);
                document.getElementById('notesPreview').innerHTML = html;
            });
            
            // Reactions - Proper emoji handling
            document.querySelectorAll('.reaction-btn').forEach(reactionBtn => {
                reactionBtn.addEventListener('click', function() {
                    if (!window.userSettings || !window.userSettings.liveReactions) {
                        showNotification('Reactions are disabled in your settings', 'warning');
                        return;
                    }
                    
                    const reaction = this.dataset.reaction;
                    showFloatingReaction(reaction);
                    
                    // Only broadcast if online and in a call
                    if (isOnline && currentCall) {
                        broadcastDataMessage({
                            type: 'reaction',
                            reaction: reaction,
                            userId: currentUser.uid,
                            timestamp: new Date().toISOString()
                        });
                    } else if (!isOnline) {
                        showNotification('Reaction shown locally (offline mode)', 'info');
                    }
                });
            });
            
            // Category tabs
            document.getElementById('allTab').addEventListener('click', function() {
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                document.querySelectorAll('.calls-section').forEach(section => {
                    section.classList.remove('active');
                });
                allCallsSection.classList.add('active');
                
                // Ensure mobile layout is correct
                setTimeout(fixMobileLayout, 10);
            });
            
            document.getElementById('missedTab').addEventListener('click', function() {
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                document.querySelectorAll('.calls-section').forEach(section => {
                    section.classList.remove('active');
                });
                missedCallsSection.classList.add('active');
                
                // Load missed calls if not already loaded
                if (missedCallsList.children.length === 0) {
                    loadAllCalls();
                }
                
                // Ensure mobile layout is correct
                setTimeout(fixMobileLayout, 10);
            });
            
            document.getElementById('groupsTab').addEventListener('click', function() {
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                document.querySelectorAll('.calls-section').forEach(section => {
                    section.classList.remove('active');
                });
                groupCallsSection.classList.add('active');
                
                // Load group calls if not already loaded
                if (groupCallsList.children.length === 0) {
                    loadAllCalls();
                }
                
                // Ensure mobile layout is correct
                setTimeout(fixMobileLayout, 10);
            });
            
            // Payment modal buttons
            document.getElementById('cancelPaymentBtn').addEventListener('click', () => {
                paymentModal.classList.remove('active');
            });
            
            document.getElementById('confirmPaymentBtn').addEventListener('click', async () => {
                const phoneNumber = document.getElementById('phoneNumber').value;
                const amount = parseInt(document.getElementById('paymentAmountInput').value);
                const requiredLimit = paymentModal.dataset.requiredLimit;
                
                if (!phoneNumber || phoneNumber.length !== 10 || !phoneNumber.startsWith('07')) {
                    showNotification('Please enter a valid Kenyan phone number (07XXXXXXXX)', 'info');
                    return;
                }
                
                if (amount < 500) {
                    showNotification('Minimum payment amount is KSh 500', 'info');
                    return;
                }
                
                try {
                    const paymentResult = await processPremiumPayment(phoneNumber, amount);
                    
                    if (paymentResult.success) {
                        showNotification(paymentResult.message, 'success');
                        paymentModal.classList.remove('active');
                        
                        // If payment was triggered by group call limit, retry the group call
                        if (requiredLimit && selectedContacts.length > 0) {
                            setTimeout(() => {
                                startGroupCall(selectedContacts);
                            }, 1000);
                        }
                    } else {
                        showNotification('Payment failed: ' + paymentResult.message, 'info');
                    }
                } catch (error) {
                    showNotification('Payment error: ' + error.message, 'info');
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                if (whiteboardCanvas) {
                    whiteboardCanvas.width = whiteboardCanvas.offsetWidth;
                    whiteboardCanvas.height = whiteboardCanvas.offsetHeight;
                }
                updateVideoGrid();
                fixMobileLayout();
            });
            
            // Handle before unload
            window.addEventListener('beforeunload', () => {
                if (currentCall) {
                    // Save call continuity data
                    saveCallContinuity();
                    endCall();
                }
                
                if (currentUser && isOnline) {
                    updateUserPresence(false);
                }
                
                // Clear connection check interval
                if (connectionCheckInterval) {
                    clearInterval(connectionCheckInterval);
                }
            });
            
            // Initialize call container in view-only mode when offline
            if (!isOnline) {
                // Show call container with placeholder when offline
                callContainer.classList.add('active');
                document.getElementById('callParticipants').textContent = 'Connection Required';
                document.getElementById('callStatus').textContent = 'Call features require connection';
                offlineCallPlaceholder.style.display = 'flex';
            }
            
            // Auto-refresh calls every 5 minutes if online
            if (isOnline) {
                setInterval(() => {
                    if (isOnline) {
                        startBackgroundSync();
                    }
                }, 300000); // 5 minutes
            }
        }
        
        // NEW: Load relationship insights for relationship panel
        function loadRelationshipInsights() {
            const insightsContainer = document.getElementById('relationshipInsights');
            if (!insightsContainer) return;
            
            insightsContainer.innerHTML = '';
            
            if (relationshipMemory.size === 0) {
                insightsContainer.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                        <i class="fas fa-chart-line" style="font-size: 32px; margin-bottom: 10px; opacity: 0.5;"></i>
                        <p>No relationship data yet</p>
                        <p style="font-size: 12px; margin-top: 5px;">Make more calls to see insights here</p>
                    </div>
                `;
                return;
            }
            
            // Sort by most calls
            const sortedMemories = Array.from(relationshipMemory.entries())
                .sort((a, b) => b[1].totalCalls - a[1].totalCalls)
                .slice(0, 10); // Top 10
            
            sortedMemories.forEach(([userId, memory]) => {
                getContactNameWithFallback(userId).then(contactName => {
                    const insights = getRelationshipInsights(userId);
                    
                    const insightItem = document.createElement('div');
                    insightItem.className = 'participant-item';
                    insightItem.innerHTML = `
                        <div class="participant-avatar">
                            <span>${contactName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2)}</span>
                        </div>
                        <div class="participant-info">
                            <div class="participant-name">${contactName}</div>
                            <div class="participant-status active">
                                <i class="fas fa-phone"></i>
                                Called ${memory.totalCalls} times
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 3px;">
                                ${insights.frequency === 'Frequent contact' ? '<i class="fas fa-star" style="color: var(--happy-color);"></i> Frequent contact' : 
                                  insights.frequency === 'Regular contact' ? '<i class="fas fa-history" style="color: var(--primary-color);"></i> Regular contact' : 
                                  '<i class="fas fa-user-clock" style="color: var(--neutral-color);"></i> Occasional contact'}
                                ${insights.lastCall !== null ? `  Last call: ${insights.lastCall}d ago` : ''}
                                ${insights.commonMood ? `  Usually ${insights.commonMood}` : ''}
                            </div>
                        </div>
                    `;
                    
                    insightsContainer.appendChild(insightItem);
                });
            });
        }
        
        console.log('Video call system initialized successfully');
        showNotification('Call history loaded', 'success');
    </script>
</body>
</html>